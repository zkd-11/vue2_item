[TOC]



# 6.12   10:40

# 包管理工具与依赖包

## Node.js

>
>
>Node.js 提供了许多功能和模块，使得开发者能够在服务器端构建各种类型的应用程序。以下是 Node.js 的一些常见功能和用途：
>
>1. 服务器端开发：Node.js 提供了一个轻量级的、高效的服务器端运行环境，使开发者可以使用 JavaScript 构建服务器端应用程序，如 Web 应用程序、API、实时通信应用等。
>2. 命令行工具：Node.js 可以用于编写命令行工具，开发者可以使用 JavaScript 来构建自定义的命令行工具，用于自动化任务、构建流程、脚本等。
>3. 数据库操作：Node.js 可以与多种数据库进行交互，如 MongoDB、MySQL、PostgreSQL 等，使开发者可以通过 JavaScript 进行数据库操作。
>4. 文件操作：Node.js 提供了丰富的文件系统模块，使开发者可以读取、写入、修改和删除文件，进行文件和目录的操作。
>5. 实时通信：Node.js 具有非阻塞的 I/O 操作特性，使其非常适合构建实时通信应用，如聊天应用、协作工具、游戏等。
>6. 构建工具和任务自动化：Node.js 可以用于构建工具和任务自动化，如 Gulp、Grunt、Webpack 等，开发者可以使用 JavaScript 编写任务脚本，自动化构建和部署项目。
>7. 代理服务器：Node.js 可以作为代理服务器，将请求转发到不同的服务器，并对请求和响应进行处理和修改。
>
>这只是 Node.js 的一些常见用途，由于其灵活性和强大的生态系统，开发者可以根据需求使用 Node.js 进行各种类型的开发。



## npm

>
>
>是的，npm（Node Package Manager）是一个用于管理和分发JavaScript包的工具。它是Node.js生态系统的一部分，并且是最常用的包管理器之一。
>
>通过npm，开发人员可以方便地安装、更新和卸载各种JavaScript包和模块。npm提供了一个庞大的包仓库（Registry），其中包含了大量的开源JavaScript包供开发人员使用。您可以使用npm命令行工具来执行各种操作，如安装包、查看包信息、发布自己的包等。
>
>以下是npm的一些常用功能：
>
>1. 包管理：使用`npm install`命令可以安装项目所需的包。通过指定包的名称和版本，npm会自动下载并安装它们。还可以使用`npm uninstall`命令卸载已安装的包。
>
>2. 版本管理：npm使用语义化版本控制（Semantic Versioning）来管理包的版本。您可以通过指定特定版本号或使用版本范围来安装包，例如`npm install package@1.0.0`或`npm install package@^1.0.0`。
>
>3. 包发布：开发人员可以使用npm将自己编写的包发布到npm仓库，供其他开发人员使用。发布包需要一个npm账号，并使用`npm publish`命令完成发布过程。
>
>4. 脚本执行：通过在项目的`package.json`文件中定义`scripts`字段，您可以使用npm运行自定义的脚本命令。例如，可以定义一个`build`脚本用于构建项目，然后使用`npm run build`命令执行该脚本。
>
>5. 其他功能：npm还提供了其他一些功能，如包搜索、包更新、包依赖解析、包发布管理等。
>
>总的来说，npm是一个非常强大和方便的工具，可以帮助开发人员轻松管理和使用JavaScript包，提高开发效率，并促进代码共享和社区协作。



### npm理解为js的应用商城

>是的，将npm比喻为JavaScript的应用商城是一个很好的方式来理解它的作用。就像应用商城提供了各种应用程序供用户下载和使用一样，npm提供了大量的JavaScript包供开发人员在其项目中使用。
>
>类似于应用商城中的应用程序，npm中的包也是经过打包和发布的，具有特定的功能和用途。开发人员可以通过npm安装这些包，并将它们用于他们的项目中。这些包包含了各种功能，例如UI组件库、数据处理库、网络请求库、工具函数等，可以帮助开发人员加快开发速度，提高代码质量，避免重复劳动。
>
>类似于应用商城中的应用评分和评论，npm中的包也有版本号和用户评价，开发人员可以选择适合自己需求的包版本，并参考其他用户的评价和建议来选择可靠的包。
>
>因此，将npm比喻为JavaScript的应用商城是一种直观的方式，有助于理解npm的作用和重要性。



### npm: Node.js的包管理工具

>npm（Node Package Manager）属于 Node.js 生态系统中的包管理工具，它主要用于管理和发布 JavaScript 包。因此，可以将 npm 归类为以下功能之一：
>
>- 包管理：npm 提供了一种方便的方式来安装、更新、卸载和管理 JavaScript 包。开发者可以通过 npm 快速找到并安装所需的包，以便在自己的项目中使用。
>
>通过 npm，开发者可以从 npm 注册表（npm registry）中下载和安装包，也可以将自己的包发布到注册表中供其他开发者使用。npm 提供了丰富的命令行工具，如 `npm install`、`npm update`、`npm uninstall` 等，用于管理包的依赖关系、版本控制等。
>
>除了包管理外，npm 还提供了其他功能，如项目初始化、脚本执行、包版本控制等。它是 Node.js 开发过程中不可或缺的工具之一，为开发者提供了方便和便利。



### yarn可以通过node.js下载， npm相当于node自带的包管理工具， yarn为重新下载的工具

>
>
>Yarn 和 npm 都是基于 Node.js 平台的包管理工具，它们都可以通过 Node.js 来安装和运行。
>
>npm 是 Node.js 默认的包管理工具，随同 Node.js 的安装一起提供。它可以用来安装、更新和管理 JavaScript 包，并提供了一些命令行工具来帮助开发者进行包的管理和发布。
>
>Yarn 则是由 Facebook 创建的另一种包管理工具，它旨在改进 npm 的性能和可靠性。Yarn 通过并行下载和缓存机制来加快包的安装速度，并引入了锁定文件 `yarn.lock` 来确保在不同环境中使用相同的包版本。Yarn 在设计上更注重稳定性和可复现性，以及更好的依赖解析和版本控制。
>
>尽管 npm 是 Node.js 自带的包管理工具，但你也可以使用 npm 来下载和安装 Yarn。可以通过 npm 全局安装 Yarn，然后就可以使用 `yarn` 命令来运行 Yarn。
>
>总结来说，npm 和 Yarn 都是用于管理 JavaScript 包的工具，它们都可以通过 Node.js 下载和运行。npm 是 Node.js 自带的包管理工具，而 Yarn 是由 Facebook 创建的一种更快、更可靠的包管理工具，可以通过 npm 安装和使用 Yarn。



## npm和yarn和pnpm的优缺点

>
>
>下面是对 npm、Yarn 和 pnpm 的一些优缺点的总结：
>
>npm：
>- 优点：
>  - 默认随同 Node.js 安装，无需额外安装。
>  - 社区庞大，拥有广泛的开源包。
>  - 支持多个平台和操作系统。
>  - 提供了许多有用的命令和功能，如脚本执行、包版本管理等。
>
>- 缺点：
>  - 安装依赖包时速度较慢。
>  - 并行安装包的能力相对较弱。
>  - 包的安装位置较为分散，可能导致项目体积较大。
>  - 某些命令的输出信息较为冗长。
>
>Yarn：
>- 优点：
>  - 安装速度较快，使用了并行下载和缓存机制。
>  - 锁定包版本，确保团队成员之间安装的包版本一致。
>  - 提供了更简洁、易读的输出信息。
>  - 支持工作区（workspaces）特性，方便管理多包项目。
>
>- 缺点：
>  - 安装过程相对于 npm 复杂一些，需要先全局安装 Yarn。
>  - 部分情况下可能与某些 npm 工具不兼容。
>
>pnpm：
>- 优点：
>  - 安装速度快，采用了符号链接（symlink）的方式进行包管理。
>  - 每个包只安装一份，节省磁盘空间。
>  - 可以在多个项目之间共享包，提高效率。
>  - 与 npm 兼容，可以直接使用 npm 命令。
>
>- 缺点：
>  - 某些情况下可能存在兼容性问题。
>  - 社区相对较小，相比 npm 和 Yarn，可能更少的资源和支持。
>
>选择使用哪个包管理工具取决于个人或团队的需求和偏好。npm 是最常见和默认的选择，Yarn 和 pnpm 则提供了更快速、一致性管理和其他附加功能。可以根据项目的具体要求和团队的实际情况进行选择。



npm和yarn的锁定包功能差异

>
>
>虽然npm和Yarn都提供了锁定包版本的功能，但它们在锁定机制上存在一些差异。
>
>在npm中，锁定包的机制是通过`package-lock.json`文件来实现的。`package-lock.json`文件记录了当前项目中每个依赖包的精确版本和依赖关系。它还包括了每个包的下载地址和校验和等信息。当运行`npm install`时，npm会根据`package-lock.json`中的版本信息来确保安装的包与锁定文件中的版本一致。
>
>在Yarn中，锁定包的机制是通过`yarn.lock`文件来实现的。`yarn.lock`文件类似于`package-lock.json`，也记录了每个依赖包的精确版本和依赖关系。但与`package-lock.json`不同的是，`yarn.lock`文件还包含了每个包的完整解析树，即它会明确记录每个包的依赖树结构。这样可以确保在安装过程中使用相同的依赖树结构，而不仅仅是版本一致。
>
>这种差异导致了在处理依赖冲突时的行为不同。npm在解决依赖冲突时可能会选择更新依赖包的版本，以解决冲突。而Yarn会尽量保持依赖树结构的稳定性，尽量避免更新包的版本。这使得Yarn在处理依赖冲突时更加可预测和稳定。
>
>总的来说，虽然npm和Yarn的锁定机制都可以确保团队成员之间安装的包版本一致，但Yarn的锁定机制更加严格，可以提供更可靠的依赖管理。



## Yarn会尽量保持依赖树结构的稳定性，尽量避免更新包的版本

是的，依赖树指的是包与包之间的关系。在一个项目中，你可能会有多个依赖包，而这些依赖包之间可能存在着依赖关系。依赖树是指这些包之间的层次结构，其中每个包可以依赖于其他包。

例如，你的项目可能依赖于包A，而包A又依赖于包B和包C。那么在这个依赖树中，包A就是根节点，包B和包C是A的子节点。如果包B还依赖于包D和包E，那么包D和包E就是B的子节点。

当使用包管理工具进行安装时，工具会根据依赖树的结构来确定哪些包需要被安装，并且按照正确的顺序安装它们，以满足依赖关系。

Yarn的锁定机制会尽量保持依赖树的稳定性，这意味着它会尽量避免更新包的版本，以保持依赖树的结构不变。这样做的目的是确保依赖关系不被破坏，减少可能的冲突和不一致性。这使得Yarn在处理依赖冲突时更加可预测和稳定。



### yarn的包依赖机制更加稳定

>
>
>NPM也使用依赖树来管理包之间的依赖关系，类似于Yarn。当你使用NPM进行包安装时，它会解析项目的依赖关系，并构建一个依赖树来确定需要安装的包和版本。
>
>然而，NPM和Yarn在锁定机制上存在一些差异。在NPM中，它使用的是`package-lock.json`文件来记录确切的包版本。这个文件包含了项目中每个包的精确版本信息，包括它们的依赖关系。当运行`npm install`时，NPM会根据`package-lock.json`中的版本信息来安装包，以确保每个开发人员或构建环境都安装相同的版本。
>
>然而，**NPM在锁定版本时可能存在一些问题。由于包的版本更新频繁，如果在安装过程中没有正确更新`package-lock.json`文件，可能会导致依赖版本不一致或冲突的问题。**
>
>相比之下，Yarn的锁定机制更加严格，它会生成一个名为`yarn.lock`的锁定文件，记录了确切的包版本和依赖关系。这种机制更加可靠，能够提供更一致的依赖解析和版本控制。
>
>综上所述，尽管NPM也使用依赖树来管理包的依赖关系，但在锁定机制和版本控制方面，Yarn的实现更加可靠和严格。



### npm解析package.json

当使用 npm 安装依赖时，它会解析项目的 package.json 文件并根据其中的依赖项列表下载所需的包。默认情况下，npm 会尝试下载最新的符合要求的包版本，并在每次安装时更新 package-lock.json 文件。

如果想要确保每次安装时都使用相同的依赖版本，可以在项目中使用 package-lock.json 文件。package-lock.json 文件会记录每个包的确切版本号，以及其依赖关系树的详细信息。这样，在安装依赖时，npm 会根据 package-lock.json 文件来确定要安装的确切版本，从而保证每次安装时依赖版本的一致性。

通过这种方式，即使多个开发者在不同的环境中安装依赖，也可以保证它们使用的是相同的版本，减少依赖冲突和不一致性的问题。



## 依赖失效

>
>
>依赖失效可能导致某些模块无法正常工作。依赖失效通常是由以下几种情况引起的：
>
>1. 版本不一致：如果依赖的版本与当前使用的模块不兼容，可能会导致模块无法正常工作。
>2. 依赖冲突：当两个或多个依赖模块依赖于同一个模块的不同版本时，可能会导致依赖冲突。这可能会导致模块无法正确加载或发生运行时错误。
>3. 被删除或迁移的依赖：有时，某些依赖可能会被开发者删除或迁移，导致原本依赖这些模块的代码无法找到对应的依赖而出现错误。
>
>为了避免依赖失效的问题，确保在项目中使用准确的依赖版本，并尽可能使用锁定依赖版本的机制（如 package-lock.json 或 yarn.lock）。此外，定期更新依赖项，确保使用最新的稳定版本，以修复可能存在的问题和漏洞。



### npm尝试更新最新的依赖包，可能会导致原依赖关系失效

>
>
>npm 在每次安装依赖时会尝试下载最新符合要求的包版本，并更新 package-lock.json 文件。这意味着如果某个依赖包的新版本引入了不兼容的更改或有依赖关系的变动，可能会导致原项目的功能失效。
>
>依赖包之间的关系是一个非常重要的因素。当一个依赖包更新到一个新版本时，它可能会依赖于其他的包的不同版本或者引入一些不兼容的更改，这可能会导致依赖关系冲突或功能的破坏。
>
>为了避免依赖关系导致的问题，可以使用锁定依赖版本的机制，如 package-lock.json 或 yarn.lock 文件。这样可以确保每个人安装的依赖版本一致，减少依赖关系的不一致性带来的问题。
>
>此外，定期进行依赖更新和测试也是很重要的，以确保项目的依赖关系保持稳定和兼容。可以使用工具来自动检测和解决依赖关系的问题，如 npm-check 或者 npm audit。



### 最大程度地避免依赖失效的方法

要最大程度地避免依赖失效的情况，可以考虑以下几个方面：

1. 锁定依赖版本：使用锁定依赖版本的机制，如 npm 的 package-lock.json 或者 yarn 的 yarn.lock 文件，确保团队成员之间安装的依赖版本一致。

2. 定期更新依赖：定期检查并更新项目的依赖，可以使用工具如 npm-check 或者 npm audit 来检测依赖的更新和安全问题。及时更新依赖可以获得更好的兼容性和安全性。

3. 仔细选择依赖包：在选择依赖包时，可以考虑其稳定性、维护活跃度和社区支持等因素。优先选择受欢迎、可靠的依赖包，并查看其文档、GitHub 上的问题和解决方案，了解其质量和稳定性。

4. 进行充分的测试：在引入新的依赖包或者更新现有的依赖包后，进行充分的测试，确保项目的功能和兼容性没有受到影响。

npm-check 可以帮助检查项目中的依赖更新，并提供与当前版本不兼容的依赖的警告。它可以列出哪些依赖包需要更新，并提供更新命令。然而，它并不会自动更新依赖包的版本，需要手动执行相应的更新命令。

在更新依赖包时，需要谨慎评估更新带来的潜在影响，并在更新前进行充分的测试。



## 存在依赖包要求用户必须更新

> 是的，有时候依赖包可能会要求用户必须更新到某个特定版本或者更新到符合一定范围的版本。这通常是因为新版本可能包含了重要的 bug 修复、安全性改进或者功能增强等。如果用户不更新到要求的版本，可能会导致依赖包的功能失效、性能问题或者安全漏洞。
>
> 在这种情况下，依赖包通常会在其文档或者发布说明中明确指出要求的版本范围，并提供相应的更新指南。用户需要根据依赖包的要求来更新相应的版本，以确保项目的正常运行。
>
> 在使用 npm 或者 yarn 等包管理工具时，可以使用命令来更新特定的依赖包版本，例如使用 `npm update <package-name>` 或者 `yarn upgrade <package-name>` 命令来更新特定依赖包的版本。
>
> 需要注意的是，在更新依赖包版本时，也要注意可能引入的兼容性问题和潜在的影响。因此，在更新依赖包之前，最好先阅读相关的更新说明、文档和社区反馈，以便了解更新可能带来的变化和注意事项，并进行适当的测试和验证。



### 依赖包可以被理解为项目所依赖的外部软件包或库

> 它们是为了提供特定功能或者实现特定需求而被引入到项目中的。依赖包可以包含 JavaScript 代码、样式表、图像文件等资源，以及必要的配置和元数据。
>
> 依赖包可以是开源的或者商业的，它们可以由个人开发者、组织或者社区维护。通过使用依赖包，开发者可以在项目中利用已有的功能和代码，避免重复劳动，提高开发效率。
>
> 依赖包可以通过包管理工具（如 npm、Yarn 或 pnpm）进行下载和安装。这些工具会根据项目的需求和配置，自动解析项目所需的依赖关系，并下载对应的依赖包到指定的目录中。项目在运行时可以引入这些依赖包，以使用其中提供的功能和资源。
>
> 因此，可以将依赖包视为项目所使用的应用程序的组成部分，通过引入适当的依赖包，开发者可以利用这些功能丰富和扩展项目的能力。





### 依赖包如果不被维护，会导致依赖失效

> 是的，如果一个依赖包不再被维护或更新，可能会导致依赖失效的问题。这种情况下，依赖包可能存在安全漏洞、功能缺陷或与其他依赖包的不兼容性等问题。如果项目依赖的包不再得到维护，这些问题可能无法得到修复，从而对项目的稳定性、安全性和可用性产生影响。
>
> 在选择依赖包时，最好考虑一些因素，例如依赖包的活跃度、维护者的声誉、社区支持和更新频率等。选择广受支持和维护良好的依赖包可以降低依赖失效的风险，并确保项目能够保持最新的功能和安全性。
>
> 此外，如果某个依赖包确实不再维护或存在严重问题，开发团队可能需要寻找替代方案或者考虑自行开发相关功能，以避免项目受到依赖失效的影响。定期检查和更新依赖包，及时处理依赖包的问题也是保持项目健康和可靠的重要步骤。



## 扩展知识： webView2 

WebView2 是一种现代化的 Web 内容呈现控件，它是 Microsoft Edge 浏览器的嵌入式版本，可用于在应用程序中显示 Web 内容。它提供了一个可嵌入的浏览器引擎，使开发人员能够在自己的应用程序中加载和显示网页内容。

webView2 具有以下作用和优势：

1. 显示网页内容：通过 WebView2，您可以在**应用程序的界面中嵌入一个浏览器控件**，用于加载和显示网页内容。这使得应用程序能够以更丰富的方式呈现信息，包括网页、在线文档、媒体内容等。

2. 支持现代 Web 技术：WebView2 使用 Microsoft Edge 的浏览器引擎，因此它支持最新的 Web 标准和技术。这意味着您可以在应用程序中使用最新的 HTML、CSS 和 JavaScript 特性，以及支持响应式设计、动态内容和交互性。

3. 可自定义和扩展：WebView2 提供了丰富的 API 和事件，使开发人员能够对其进行自定义和扩展。您可以控制浏览器的行为、样式和交互方式，以适应应用程序的需求，并与应用程序的其他部分进行集成。

4. 与本地应用程序集成：WebView2 可以与本地应用程序进行无缝集成，使得应用程序能够通过 JavaScript 和 .NET/C++ 的互操作性，实现与网页内容的交互。您可以在应用程序中调用 JavaScript 函数、监听网页事件，甚至在应用程序和网页之间传递数据。

综上所述，webView2 是一种功能强大的工具，可将 Web 内容嵌入到应用程序中，为开发人员提供了更丰富的界面和交互体验。



### 安装过程中没有正确更新package-lock.json文件，可能会导致依赖版本不一致或冲突

> 是的，如果在项目开发过程中没有正确更新或管理 package-lock.json 文件，可能会导致依赖版本不一致或冲突的问题。这种情况下，你的本地环境可能能够正常运行项目，但将项目打包给别人时，由于依赖关系未正确更新，别人的环境中可能会出现项目启动失效的情况。
>
> 为了避免这种问题，你可以采取以下措施：
>
> 1. 确保在安装或更新依赖包时使用准确的命令，如使用 `npm install` 或 `npm update`。这将自动更新 package-lock.json 文件，并确保依赖版本的一致性。
>
> 2. 提交项目时，一并提交 package-lock.json 文件。这样，其他人在拉取项目时将得到与你本地相同的依赖版本。
>
> 3. 在项目开发过程中，定期检查和更新依赖包。可以使用工具如 npm-check 或 npm outdated 来检查依赖包的最新版本，并及时更新。
>
> 4. 在团队协作中，建议使用相同的包管理工具和版本控制工具，以确保依赖的一致性。
>
> 总之，正确管理和更新依赖关系是保证项目可靠性和可移植性的重要步骤。通过遵循最佳实践和使用合适的工具，可以最大程度地减少依赖版本不一致导致的问题。



### package.json和yarn.lock 这两个可以同时存在



> 是的，`package.json`和`yarn.lock`这两个文件可以同时存在，并且在使用Yarn管理依赖时通常会同时生成它们。
>
> `package.json`是一个包含项目元数据和依赖项列表的文件，它描述了项目的配置信息、脚本命令和依赖项等。无论使用npm还是Yarn，都会生成一个`package.json`文件来记录项目的配置信息。
>
> `yarn.lock`是Yarn特有的文件，用于确保在不同环境下安装的依赖版本一致。它记录了项目依赖项的精确版本号，以及依赖项之间的依赖关系，从而保证了在执行`yarn install`命令时安装的依赖版本与之前一致。
>
> 因此，在使用Yarn管理依赖时，建议同时提交`package.json`和`yarn.lock`文件到版本控制系统，以便其他人可以根据这两个文件来安装和管理项目的依赖。这样可以确保其他人在执行`yarn install`命令时获得与你在开发环境中使用的相同的依赖版本。



### 个人开发一般只使用一种包工具



> 个人开发时一般可以选择使用一种包管理工具，如npm或Yarn，以简化项目的依赖管理和构建流程。选择哪种包管理工具主要取决于个人的喜好和项目需求。
>
> npm是JavaScript生态系统中最常用的包管理工具，具有广泛的支持和社区。它提供了丰富的功能和命令，能够满足大多数项目的需求。如果你对npm较为熟悉，并且你的项目没有特殊需求，那么使用npm是一个不错的选择。
>
> Yarn是由Facebook开发的另一种包管理工具，旨在提供更快速、安全和可靠的依赖管理体验。它具有与npm类似的功能，同时还提供了一些额外的功能，如离线模式、并行安装等。如果你对Yarn感兴趣，或者你的项目需要利用Yarn的特定功能，那么使用Yarn也是可以的。
>
> 在选择包管理工具时，还可以考虑项目团队的共识和一致性。如果你与其他开发者合作，那么最好与他们协商一致，选择一种共同使用的包管理工具，以确保项目的一致性和协作效率。
>
> 无论选择使用npm还是Yarn，重要的是在项目中始终保持一致，遵循相同的依赖管理流程，并将相关的配置文件（如`package.json`和`yarn.lock`）提交到版本控制系统中，以便团队成员可以轻松地获取项目所需的依赖项。





## Webpack

> Webpack是一个现代的静态模块打包工具，用于构建前端项目。它可以将各种类型的文件（如JavaScript、CSS、图片等）视为模块，并将它们打包成一个或多个优化的静态资源文件。
>
> Webpack的主要功能包括：
>
> 1. 模块化支持：Webpack可以将项目中的各个模块进行依赖分析，并按需加载和组合它们。这使得开发者可以使用模块化的方式编写代码，提高代码的可维护性和复用性。
>
> 2. 资源打包：Webpack可以处理各种类型的文件，并通过加载器（Loader）将它们转换为合适的模块。例如，可以使用Babel加载器将ES6+的JavaScript代码转换为浏览器可识别的ES5代码，或使用CSS加载器处理CSS文件。
>
> 3. 代码分割：Webpack支持将代码分割成多个块，可以实现按需加载，提高页面加载性能。这样可以将常用的代码和不常用的代码分割开来，减小初始加载的文件大小。
>
> 4. 插件系统：Webpack拥有丰富的插件生态系统，开发者可以通过插件来扩展和定制Webpack的功能。常见的插件用于优化、压缩、提取公共代码等。
>
> 5. 开发环境支持：Webpack提供了开发环境的工具和配置，例如热模块替换（Hot Module Replacement）、源映射（Source Maps）等，方便开发者在开发过程中进行调试和测试。
>
> 通过适当配置Webpack，开发 者可以将多个模块和资源打包成一个或多个静态文件，并优化这些文件的大小和加载速度，从而提高前端项目的性能和用户体验。
>
> 使用Webpack需要编写配置文件（通常为webpack.config.js），配置入口文件、输出路径、加载器、插件等信息。然后可以使用命令行工具或集成到构建工具中进行打包操作。
>
> 总结起来，Webpack是一个功能强大的前端打包工具，用于将各种资源打包成优化的静态 文件，实现模块化开发和优化性能。



## jquery的$.语法表示什么

> 在 jQuery 中，`$` 是 jQuery 对象的别名或缩写。它是一个全局函数，用于访问和操作 jQuery 库提供的功能和方法。
>
> 通过 `$` 可以快速访问 jQuery 库中的功能，例如选择器、DOM 操作、事件处理、动画效果等。使用 `$` 可以简化代码，并提供更简洁的语法来操作和处理页面元素。
>
> 例如，`$("#btn")` 表示选取页面上 id 为 "btn" 的元素，`$(".container")` 表示选取所有类名为 "container" 的元素，`$("ul li")` 表示选取所有 ul 元素下的 li 元素。
>
> 总之，`$` 是 jQuery 的主要入口，使用它可以方便地使用 jQuery 提供的功能和方法。



## $.proxy()

> `$.proxy()` 是 jQuery 提供的一个方法，用于修改函数的上下文（也就是函数内部的 `this` 指向）。
>
> 在你的代码中，`$.proxy(this.handleBtnClick, this)` 的作用是将 `this.handleBtnClick` 函数的上下文（即 `this` 指向）设置为 `this`，也就是 `Page` 对象的实例。
>
> 这是因为在 JavaScript 中，函数的执行上下文（`this`）是根据调用方式确定的。在事件处理函数中，常常会遇到上下文丢失的问题，即事件处理函数中的 `this` 不再指向原来的对象。为了确保事件处理函数中的 `this` 指向正确，可以使用 `$.proxy()` 方法来修改函数的上下文。
>
> 通过 `$.proxy(this.handleBtnClick, this)`，你将 `this.handleBtnClick` 函数的上下文设置为当前 `Page` 对象的实例，这样在 `handleBtnClick` 函数中，`this` 就可以正确地指向 `Page` 对象的实例，从而可以访问和操作 `Page` 对象中的属性和方法。





## vue中组件概念

>
>
>在Vue.js中，组件是构建用户界面的基本单元。它们可以独立地封装和重用，并具有自己的模板、样式和逻辑。Vue组件提供了一种组织和管理代码的方式，使开发者能够将复杂的应用程序拆分为更小、更可维护的部分。
>
>Vue组件具有以下特点：
>
>1. **模板**: 组件使用Vue的模板语法来定义其结构和内容。模板可以包含HTML标记和Vue特定的指令，用于绑定数据和处理事件。
>
>2. **数据**: 组件可以拥有自己的数据对象，用于存储和管理组件内部的状态。数据可以通过插值表达式和指令在模板中进行绑定。
>
>3. **生命周期钩子**: 组件具有生命周期钩子函数，可以在组件的不同阶段执行特定的操作，例如创建前、创建后、更新前、更新后等。这些钩子函数可以用于执行初始化逻辑、数据获取、清理等操作。
>
>4. **样式**: 组件可以拥有自己的样式，可以使用CSS或预处理器（如Sass、Less）来定义组件的样式规则。样式可以通过作用域或CSS模块化来确保组件样式的隔离性和可重用性。
>
>5. **事件与方法**: 组件可以定义自己的方法，并使用Vue的事件系统来处理DOM事件和自定义事件。组件内部的方法可以通过绑定到模板中的事件指令来触发。
>
>6. **组件通信**: 组件之间可以通过属性传递和事件触发进行通信。父组件可以通过属性将数据传递给子组件，子组件可以通过事件将数据发送给父组件或其他组件。
>
>7. **组件复用**: 组件可以被复用，可以在同一个应用程序的不同地方使用多次。通过提供不同的属性和配置，可以在不同的上下文中使用同一个组件。
>
>Vue组件的概念使得前端开发更加模块化、可维护和可扩展，提供了一种组织代码的有效方式，同时也增强了应用程序的可重用性和可测试性。



## component

> 在Vue.js中，组件（Component）是构建用户界面的可复用模块。组件可以包含 HTML、CSS 和 JavaScript，用于定义特定的功能和外观。
>
> 在Vue中，可以通过 Vue.component() 方法或者单文件组件（.vue 文件）的方式来创建组件。
>
> 以下是创建和使用组件的一般步骤：
>
> 1. 创建组件：
>    - 使用全局注册方式：
>      ```javascript
>      Vue.component('my-component', {
>        // 组件选项
>      });
>      ```
>    - 使用单文件组件方式：创建一个以 `.vue` 扩展名的文件，其中包含模板、样式和脚本：
>      ```html
>      <template>
>        <!-- 模板内容 -->
>      </template>
>      
>      <script>
>      export default {
>        // 组件选项
>      };
>      </script>
>      
>      <style scoped>
>        /* 组件样式 */
>      </style>
>      ```
>
> 2. 使用组件：
>    - 在另一个组件的模板中使用：
>      ```html
>      <template>
>        <div>
>          <my-component></my-component>
>        </div>
>      </template>
>      ```
>    - 使用单文件组件方式：在父组件中引入并注册子组件：
>      ```javascript
>      import MyComponent from './MyComponent.vue';
>      
>      export default {
>        components: {
>          MyComponent
>        },
>        // ...
>      };
>      ```
>
> 组件可以具有自己的数据、方法、生命周期钩子等。通过组件的 props 属性，可以向子组件传递数据和参数。
>
> 组件化是 Vue.js 的核心概念之一，它提供了一种模块化的方式来构建复杂的用户界面，使得应用程序的代码更易于理解、维护和重用。



## 被渲染的为父组件， 接受数据并将数据进行渲染返回的为子组件



> 在 Vue.js 中，父组件是指包含子组件的组件，而子组件是被包含在父组件中的组件。
>
> 在你提供的代码中，父组件是包含 `<todo-item>` 组件的组件。父组件通过使用 `<todo-item>` 组件，并传递数据给它的 `content` 属性，将数据传递给子组件。
>
> 父组件负责创建和管理子组件，并可以通过传递 props 给子组件，将数据或状态传递给子组件。子组件可以使用这些 props 接收并使用父组件传递的数据。
>
> 通常情况下，父组件负责整体页面的布局和逻辑控制，而子组件负责特定功能模块的实现。通过将应用程序拆分为父组件和子组件的层次结构，可以使代码更具可维护性和可复用性。
>
> 因此，父组件是包含子组件的组件，而子组件是被包含在父组件中的组件。父组件通过 props 将数据传递给子组件，并控制子组件的行为和显示。
>
> 

指将todo-item标签渲染为li标签

> 是的，你所给的代码中通过 Vue.component 定义了一个名为 "TodoItem" 的组件，并将其注册到 Vue 实例中。然后在父组件的模板中使用 `<todo-item>` 标签来使用这个组件。
>
> `<todo-item v-bind:content="content" v-for="item in list"></todo-item>` 这句代码的作用是将 `<todo-item>` 组件渲染为 `<li>` 标签，并且通过 `v-for` 指令遍历 `list` 数组的每个元素，为每个元素创建一个 `<todo-item>` 组件实例。
>
> 在这里，通过 `v-bind:content="content"` 将父组件的 `content` 数据传递给子组件的 `content` 属性。子组件通过定义 `props: ["content"]` 来接收父组件传递的数据，并在模板中使用 `{{ content }}` 将数据渲染到 `<li>` 标签中。
>
> 因此，这段代码的作用是将父组件中的 `list` 数组的每个元素渲染为一个 `<li>` 标签，并使用 `<todo-item>` 组件来实现渲染和数据传递的功能。





### 注册是类似身份标识

>
>
>是的，可以将组件的注册理解为给组件一个身份标识，以便在模板中使用该组件时能够正确识别并渲染它。
>
>通过使用 `Vue.component` 方法注册组件时，需要提供一个组件名称作为参数，并将组件选项传递给该方法。注册后，该组件就可以在其他组件的模板中通过其名称来引用。
>
>例如，在给定的代码中，使用 `Vue.component` 方法注册了一个名为 "TodoItem" 的组件，然后在父组件的模板中使用 `<todo-item>` 标签来引用该组件。这样，Vue 就能识别并渲染出正确的子组件。
>
>所以，注册组件可以被看作是给组件分配一个身份标识，以便在模板中引用和使用该组件。



### 解析时为识别为父组件， 通过全局组件注册的方法后， 被渲染变成了子组件

>你理解得很对。当你在父组件的模板中使用一个组件标签（例如 `<todo-item>`），这个标签在解析阶段会被识别为父组件，但在渲染阶段，如果这个组件在全局或局部中被注册，它会被实例化成子组件并进行渲染。这是因为在 Vue 的组件系统中，父组件负责使用和嵌套子组件，而子组件是被父组件所包含和管理的。
>
>所以，在父组件的模板中使用 `<todo-item>` 标签时，它被解析为对注册的组件（即子组件）的使用，并且被视为父组件中的子组件。实际渲染时，子组件会在父组件的上下文中进行渲染和展示。



## `this.$emit` 是 Vue 实例的一个方法，用于触发自定义事件

>
>
>`this.$emit` 是 Vue 实例的一个方法，用于触发自定义事件。
>
>在 Vue 组件中，你可以使用 `this.$emit` 方法来触发一个自定义事件，并传递数据给父组件或其他监听该事件的组件。
>
>语法如下：
>
>```javascript
>this.$emit(eventName, payload);
>```
>
>- `eventName` 是自定义事件的名称，可以自定义为你喜欢的名称。
>- `payload` 是要传递给监听事件的组件的数据，可以是**任意类型的数据**。
>
>当调用 `this.$emit` 方法时，Vue 会在组件实例上触发指定的事件，并将 `payload` 数据传递给监听该事件的组件。
>
>在父组件中，你可以通过在子组件的标签上使用 `v-on` 或简写 `@` 来监听该自定义事件，并在对应的方法中处理传递过来的数据。
>
>以下是一个示例：
>
>```vue
><template>
>  <button @click="handleButtonClick">点击触发事件</button>
></template>
>
><script>
>export default {
>  methods: {
>    handleButtonClick() {
>      // 触发自定义事件并传递数据
>      this.$emit('custom-event', 'Hello from child component!');
>    }
>  }
>};
></script>
>```
>
>在父组件中监听该自定义事件：
>
>```vue
><template>
>  <div>
>    <child-component @custom-event="handleCustomEvent"></child-component>
>  </div>
></template>
>
><script>
>export default {
>  methods: {
>    handleCustomEvent(data) {
>      console.log(data); // 输出：Hello from child component!
>    }
>  }
>};
></script>
>```
>
>在上述示例中，当子组件的按钮被点击时，会触发自定义事件 `custom-event`，并将字符串 `'Hello from child component!'` 作为数据传递给父组件的 `handleCustomEvent` 方法。
>
>父组件中的 `handleCustomEvent` 方法会接收到传递的数据，并进行处理。
>



## v-bind 、v-for、 @click参数

>
>
>在Vue中，`v-bind`、`v-for`和`@click`是Vue的模板指令，用于在模板中绑定数据、循环遍历和处理事件。下面是它们的具体含义：
>
>- `v-bind`：用于绑定数据到元素的属性或组件的props上。它的作用是将模板中的数据和Vue实例中的数据进行绑定，实现数据的动态更新。使用方式为`v-bind:属性名`或简写为`:属性名`。例如，`<div v-bind:class="className"></div>`将`className`变量的值绑定到`class`属性上。
>
>- `v-for`：用于循环遍历数组或对象，生成重复的元素或组件。它可以遍历数组、对象的属性或者整数范围。使用方式为`v-for="item in items"`，其中`item`是每次遍历的元素，`items`是要遍历的数据源。例如，`<li v-for="item in items">{{ item }}</li>`将遍历`items`数组，生成多个`<li>`元素。
>
>- `@click`：用于监听元素的点击事件。它的作用是在元素被点击时执行指定的方法或表达式。使用方式为`@click="method"`，其中`method`是要执行的方法名。例如，`<button @click="handleClick">Click Me</button>`将在按钮被点击时执行`handleClick`方法。
>
>这些指令可以在Vue的模板中使用，通过对应的语法来实现数据绑定、循环渲染和事件处理。它们是Vue提供的强大工具，使得开发者可以更方便地处理数据和交互逻辑。



## vue的模板指令

>Vue的模板指令提供了丰富的功能和语法，用于在模板中进行数据绑定、条件渲染、循环遍历、事件处理等操作。以下是一些常用的Vue模板指令：
>
>- `v-bind`（简写为`:`）：用于绑定数据到元素的属性或组件的props上。
>- `v-if`：根据表达式的值来条件性地渲染元素。
>- `v-else`：作为`v-if`的“else”块，只在前一个兄弟元素的`v-if`为假时渲染。
>- `v-show`：根据表达式的值来条件性地显示或隐藏元素，与CSS的`display`属性相对应。
>- `v-for`：用于循环遍历数组或对象，**生成重复的元素或组件。**
>- `v-on`（简写为`@`）：用于监听元素的事件，执行相应的方法。
>- `v-model`：用于在表单元素上实现双向数据绑定。
>- `v-text`：将元素的`textContent`属性设置为绑定的表达式的值。
>- `v-html`：将元素的`innerHTML`属性设置为绑定的表达式的值，可以渲染HTML代码。
>- `v-cloak`：用于防止页面闪动，当Vue实例准备完毕时自动移除。
>
>除了以上指令，Vue还提供了更多的指令和扩展，用于处理表单验证、过渡动画、组件通信等方面的需求。你可以参考Vue的官方文档了解更多关于模板指令的详细信息。



# 6.13  13：10

## vue生命周期钩子

>Vue组件的生命周期钩子是一些特定的函数，它们会在组件的不同生命周期阶段被调用。这些生命周期钩子函数可以让你在组件的不同阶段执行特定的操作和逻辑。下面是Vue的生命周期钩子及其执行顺序：
>
>1. beforeCreate：在实例被创建之前调用，此时组件的数据和方法都还未初始化。
>
>2. created：在实例创建完成后调用，此时组件的数据和方法已经初始化完成。
>
>3. beforeMount：在组件挂载到DOM之前调用，此时模板已经编译完成，但尚未将组件挂载到页面上。
>
>4. mounted：在组件挂载到DOM后调用，此时组件已经被渲染到页面上，可以进行DOM操作和异步请求等操作。
>
>5. beforeUpdate：在组件更新之前调用，当组件的数据发生变化时会触发该钩子函数。
>
>6. updated：在组件更新完成后调用，此时组件的DOM已经更新完成。
>
>7. beforeDestroy：在组件销毁之前调用，可以在这里进行清理工作和取消事件监听等操作。
>
>8. destroyed：在组件销毁之后调用，此时组件的实例已经被销毁，不再可用。
>
>除了上述的常用生命周期钩子函数，Vue还提供了一些其他的生命周期钩子，如activated和deactivated（用于Vue的keep-alive组件）、errorCaptured（用于捕获子组件错误）等。
>
>通过使用这些生命周期钩子函数，你可以在不同的阶段执行相应的逻辑，比如初始化数据、发送请求、监听事件、清理资源等，以实现更精细的控制和交互。



##  computed: 计算属性

> 计算属性（Computed Properties）是 Vue.js 中用于处理数据计算的一种特殊属性。它们是基于其他数据属性计算而来的属性，具有缓存机制，只有在依赖的数据发生变化时才会重新计算。计算属性可以提供简洁和高效的数据计算方式，常用于对响应式数据进行复杂的逻辑运算或过滤操作。
>
> 在 Vue 组件中定义计算属性，需要在 `computed` 对象中添加属性，并指定一个函数来计算属性的值。这个函数会在每次访问该计算属性时被调用，返回计算后的值。
>
> 以下是一个示例：
>
> ```html
> <div id="app">
>   <p>原始值：{{ value }}</p>
>   <p>计算属性：{{ computedValue }}</p>
> </div>
> 
> <script>
>   var app = new Vue({
>     el: "#app",
>     data: {
>       value: 10,
>     },
>     computed: {
>       computedValue: function () {
>         // 在计算属性中对数据进行计算并返回结果
>         return this.value * 2;
>       },
>     },
>   });
> </script>
> ```
>
> 在上面的示例中，我们定义了一个计算属性 `computedValue`，它通过将 `value` 的值乘以 2 来计算属性的值。每当 `value` 发生变化时，`computedValue` 会自动重新计算。
>
> 在模板中，我们可以像访问普通属性一样访问计算属性，例如 `{{ computedValue }}`。当 `value` 的值改变时，`computedValue` 会自动更新并显示新的计算结果。
>
> 计算属性的特点是具有缓存机制，只有当计算属性依赖的数据发生改变时才会重新计算，否则会直接返回之前缓存的计算结果。这样可以提高性能，避免不必要的计算。



### Computed内的set和get函数

> 在 Vue.js 的计算属性 `computed` 中，可以使用 `get` 和 `set` 来定义属性的获取和设置操作。
>
> - `get` 函数用于获取计算属性的值。当访问计算属性时，会执行 `get` 函数，并返回计算属性的值。
>
> - `set` 函数用于设置计算属性的值。当对计算属性进行赋值时，会执行 `set` 函数，并将新的值作为参数传递给 `set` 函数。
>
> 下面是一个示例：
>
> ```html
> <div id="app">
>   <p>原始值：{{ value }}</p>
>   <input v-model="value" />
> </div>
> 
> <script>
>   var app = new Vue({
>     el: "#app",
>     data: {
>       inputValue: 0,
>     },
>     computed: {
>       value: {
>         get: function () {
>           // 获取计算属性的值
>           return this.inputValue;
>         },
>         set: function (newValue) {
>           // 设置计算属性的值
>           this.inputValue = newValue;
>         },
>       },
>     },
>   });
> </script>
> ```
>
> 在上面的示例中，我们定义了一个计算属性 `value`，其中包含 `get` 和 `set` 函数。当访问 `value` 时，会执行 `get` 函数并返回 `inputValue` 的值。当对 `value` 进行赋值时，会执行 `set` 函数并将新的值传递给 `set` 函数，然后将新的值赋给 `inputValue`。
>
> 通过使用 `get` 和 `set`，我们可以在计算属性中对数据的读取和设置进行自定义操作。这样可以方便地实现对计算属性的定制化逻辑，例如对值进行格式化、对依赖属性进行处理等。



### set设置后会在执行 get函数

在设置计算属性的值时，会先执行 `set` 函数进行赋值操作，然后再执行 `get` 函数获取更新后的计算属性的值。

这是因为在 Vue.js 中，计算属性的值是基于其依赖的响应式数据进行计算得出的。当依赖的数据发生变化时，计算属性会重新计算，并返回新的值。因此，在设置计算属性的值后，会触发计算属性的重新计算过程，然后执行 `get` 函数来获取最新的计算属性值。

举个例子，假设我们有一个计算属性 `fullName`，它依赖于 `firstName` 和 `lastName` 这两个响应式数据。当我们通过 `set` 函数设置 `fullName` 的值时，会触发计算属性重新计算，然后执行 `get` 函数获取最新的计算属性值。

```javascript
computed: {
  fullName: {
    get: function () {
      return this.firstName + ' ' + this.lastName;
    },
    set: function (value) {
      var names = value.split(' ');
      this.firstName = names[0];
      this.lastName = names[1];
    }
  }
}
```

总结起来，设置计算属性的值会先执行 `set` 函数进行赋值操作，然后会触发计算属性的重新计算过程，最后再执行 `get` 函数获取最新的计算属性值。



##  watch Vue.js 中用于观察（监听）数据变化的一个选项

> `watch` 是 Vue.js 中用于观察（监听）数据变化的一个选项。通过定义 `watch` 选项，我们可以监听指定的数据，并在数据发生变化时执行相应的操作。
>
> 在 Vue 组件中使用 `watch`，需要在 `watch` 对象中添加属性，每个属性对应一个要观察的数据，并指定一个处理函数来处理数据变化的操作。当被观察的数据发生变化时，对应的处理函数会被调用。
>
> 以下是一个示例：
>
> ```html
> <div id="app">
>   <p>原始值：{{ value }}</p>
>   <button v-on:click="increment">增加</button>
> </div>
> 
> <script>
>   var app = new Vue({
>     el: "#app",
>     data: {
>       value: 10,
>     },
>     methods: {
>       increment: function () {
>         this.value++;
>       },
>     },
>     watch: {
>       value: function (newValue, oldValue) {
>         // 在 value 发生变化时执行相应的操作
>         console.log("value 变化了，新值为：" + newValue + "，旧值为：" + oldValue);
>       },
>     },
>   });
> </script>
> ```
>
> 在上面的示例中，我们定义了一个 `watch` 对象，并添加了一个属性 `value`，表示要观察的数据。当 `value` 的值发生变化时，对应的处理函数会被调用，并接收两个参数：`newValue` 表示变化后的新值，`oldValue` 表示变化前的旧值。在示例中，我们在处理函数中打印出了新值和旧值。
>
> 当点击按钮时，`increment` 方法会增加 `value` 的值，触发数据变化，从而触发对应的 `watch` 处理函数。
>
> 使用 `watch` 可以监听数据的变化，并在变化时执行自定义的操作，例如发起异步请求、更新其他数据等。它比计算属性更适用于处理数据变化时需要执行一些额外操作的情况。





## v-if   和 v-show

>
>
>`v-show` 和 `v-if` 是 Vue.js 中用于条件性地显示或隐藏元素的指令。
>
>`v-show` 是一种基于 CSS 的显示/隐藏控制方式。当表达式的值为 `true` 时，元素会显示出来；当表达式的值为 `false` 时，元素会隐藏起来。底层实现是通过修改元素的 `display` CSS 属性来控制显示状态，因此元素仍然存在于 DOM 中，只是不可见。
>
>```html
><div v-show="isVisible">This element is shown or hidden based on the value of `isVisible`.</div>
>```
>
>`v-if` 是一种基于 DOM 元素的插入/移除控制方式。当表达式的值为 `true` 时，元素会被插入到 DOM 中；当表达式的值为 `false` 时，元素会从 DOM 中移除。每次条件发生变化时，Vue.js 会重新渲染 DOM。
>
>```html
><div v-if="isVisible">This element is inserted or removed based on the value of `isVisible`.</div>
>```
>
>在选择 `v-show` 还是 `v-if` 时，可以考虑以下因素：
>
>- 如果需要频繁切换显示状态，并且元素初始状态很少改变，使用 `v-show` 可以避免频繁的 DOM 操作，性能较好。
>- 如果需要根据条件动态地插入或移除元素，并且元素的初始状态可能会频繁改变，使用 `v-if` 更适合，因为它会根据条件重新渲染 DOM，但性能上可能略逊于 `v-show`。
>
>需要注意的是，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，根据具体的场景和性能需求，选择适合的指令进行条件渲染。



## === 和 ==之间的区别

>
>
>在 JavaScript 中，`===` 和 `==` 是比较运算符，用于比较两个值是否相等。它们之间的区别如下：
>
>1. `===`（严格相等）：进行严格的相等比较，要求比较的两个值不仅在值上相等，而且类型也必须相同。只有当值和类型都相等时，比较结果才为 `true`，否则为 `false`。
>
>2. `==`（相等）：进行宽松的相等比较，允许在比较时进行类型转换。在比较之前，会先进行类型转换，然后再进行值的比较。类型转换规则较为复杂，可能会导致一些意外的比较结果。
>
>主要区别如下：
>
>- `===` 比较更严格，要求值和类型都相等，不进行类型转换。
>- `==` 比较更宽松，允许进行类型转换，可能会产生意外的结果。
>
>示例：
>
>```javascript
>var a = 1;
>var b = '1';
>
>console.log(a === b);  // false，类型不同
>console.log(a == b);   // true，进行类型转换后值相等
>```
>
>建议在进行比较时，优先使用 `===` 进行严格相等比较，避免类型转换带来的意外结果。只在明确需要类型转换的情况下，才考虑使用 `==`。





##   元素身份标识： 一般用id（唯一且固定）



> 元素身份标识在 Vue 中非常重要。为了实现高效的渲染和更新，Vue 需要能够准确地追踪和识别每个元素的身份。
>
> 使用 id 是一种常见的元素身份标识方式，因为它们通常是唯一且固定的。Vue 可以使用 id 来追踪元素，并且在更新视图时能够快速找到需要更新的元素。
>
> 相比之下，使用数组下标作为元素身份标识是不推荐的，因为数组的顺序可能会改变，导致元素身份标识发生变化。这会导致 Vue 需要重新渲染整个列表，而不仅仅是更新变化的部分，从而降低性能。
>
> 因此，建议在 Vue 中使用唯一且固定的元素身份标识，例如使用 id 属性或其他唯一标识符，以提高渲染和更新的性能。



## vm. $ 表示 Vue 实例的一个内置方法

在 Vue.js 中，属性名称前面带有 `$` 符号的方法和属性通常是为了区分用户自定义的方法和属性。这样的命名约定可以避免与用户自定义的方法和属性发生命名冲突。

`vm.$set` 是 Vue 实例的一个内置方法，用于在响应式对象上设置属性。通过在方法名称前加上 `$` 符号，Vue.js 提供了一种清晰的命名方式，使其与用户自定义的方法和属性区分开来。

此外，Vue.js 还提供了许多其他的内置方法和属性，它们也都以 `$` 符号开头，比如 `$watch`、`$emit`、`$props` 等。这些内置方法和属性的命名方式可以帮助开发者更好地理解其作用和来源，避免命名冲突，并提高代码的可读性。



## Vue.set 和实例后对象 vm.set 不同之处

> 在 Vue 中，`Vue.set` 和实例后对象的 `vm.$set` 方法都用于在响应式对象中添加新属性或修改已有属性。它们的使用有一些不同之处：
>
> 1. `Vue.set` 是全局方法，可以在任何地方使用，而 `vm.$set` 是实例方法，只能在 Vue 实例内部使用。
>
> 2. 用法不同：
>    - `Vue.set` 的语法是 `Vue.set(obj, key, value)`，其中 `obj` 是要修改的对象，`key` 是要设置的属性名，`value` 是要设置的属性值。
>    - `vm.$set` 的语法是 `vm.$set(obj, key, value)`，其中 `vm` 是 Vue 实例，其他参数和 `Vue.set` 相同。
>
> 3. 应用场景不同：
>    - `Vue.set` 主要用于全局或跨组件的操作，比如在组件之间共享的状态对象上添加新属性。
>    - `vm.$set` 主要用于当前 Vue 实例内部的操作，比如在组件的响应式数据对象上添加新属性。
>
> 总的来说，`Vue.set` 和 `vm.$set` 的功能是相同的，都是用于在响应式对象中设置属性。它们的区别在于使用方式和应用场景。你可以根据具体的使用场景选择合适的方法来操作响应式对象。



## table标签 （复习）

> `<table>` 标签用于创建 HTML 表格，它可以包含多个子标签来定义表格的结构和内容。下面是一些常用的 `<table>` 标签及其作用：
>
> 1. `<table>`: 定义整个表格。
> 2. `<thead>`: 定义表格的表头部分。
> 3. `<tbody>`: 定义表格的主体部分。
> 4. `<tfoot>`: 定义表格的页脚部分。
> 5. `<tr>`: 定义表格的行。
> 6. `<th>`: 定义表格的表头单元格。
> 7. `<td>`: 定义表格的数据单元格。
>
> 这些标签的嵌套关系如下所示：
>
> ```html
> <table>
>   <thead>
>     <tr>
>       <th>表头单元格1</th>
>       <th>表头单元格2</th>
>     </tr>
>   </thead>
>   <tbody>
>     <tr>
>       <td>数据单元格1</td>
>       <td>数据单元格2</td>
>     </tr>
>     <tr>
>       <td>数据单元格3</td>
>       <td>数据单元格4</td>
>     </tr>
>   </tbody>
>   <tfoot>
>     <tr>
>       <td>页脚单元格1</td>
>       <td>页脚单元格2</td>
>     </tr>
>   </tfoot>
> </table>
> ```
>
> 在上面的示例中，`<thead>` 标签用于定义表格的表头部分，其中的 `<tr>` 标签表示表头的一行，`<th>` 标签定义表头的单元格。`<tbody>` 标签用于定义表格的主体部分，其中的 `<tr>` 标签表示表格的一行，`<td>` 标签定义数据单元格。`<tfoot>` 标签用于定义表格的页脚部分，其中的 `<tr>` 标签表示页脚的一行，`<td>` 标签定义页脚的单元格。
>
> 通过使用这些标签的组合，可以创建具有合适结构的表格，并在其中填充内容。





## 组件的数据属性必须以函数的形式返回



Vue 的规范要求组件的数据属性必须以函数的形式返回，而不是直接定义为对象。这样做的目的是为了确保每个组件实例都拥有独立的数据空间，以避免数据在不同组件之间相互干扰。



### vue中的ref属性 

>在 Vue 中，`ref` 是用于给元素或组件添加引用的特殊属性。通过 `ref`，你可以在 Vue 实例中访问到被引用的元素或组件。
>
>使用 `ref` 的步骤如下：
>
>1. 在模板中的元素或组件上添加 `ref` 属性，并指定一个名称，如 `ref="myRef"`。
>
>```html
><template>
>  <div>
>    <button ref="myButton">Click me</button>
>    <input ref="myInput" type="text" />
>    <my-component ref="myComponent"></my-component>
>  </div>
></template>
>```
>
>2. 在 Vue 实例中，可以通过 `$refs` 对象来访问被引用的元素或组件。`$refs` 对象是一个包含了所有被引用的元素或组件的属性的对象。
>
>```javascript
><script>
>export default {
>  mounted() {
>    const button = this.$refs.myButton;
>    const input = this.$refs.myInput;
>    const component = this.$refs.myComponent;
>
>    // 使用引用的元素或组件进行操作
>    button.innerText = 'Clicked!';
>    input.focus();
>    component.someMethod();
>  },
>};
></script>
>```
>
>通过 `$refs` 对象，你可以获取到被引用元素或组件的 DOM 节点，或者调用组件的方法。请注意，`$refs` 是一个响应式属性，当元素或组件在 DOM 中更新时，`$refs` 也会相应地更新。
>
>需要注意的是，`ref` 只在组件内部有效，不能在子组件中通过 `ref` 引用父组件的元素或组件。此外，`ref` 的值应该是唯一的，在同一个组件中不应该使用相同的引用名称。

### ref 的应用场景

>
>
>在开发项目中，可以利用 `ref` 来完成以下任务：
>
>1. DOM 操作：通过 `ref` 可以获取到特定元素的 DOM 节点，从而可以直接对其进行 DOM 操作，比如修改样式、添加/移除类名、获取/设置属性值等。
>
>2. 表单操作：通过 `ref` 可以获取表单元素的值，从而可以进行表单数据的处理、校验和提交等操作。
>
>3. 组件通信：通过 `ref` 可以获取到子组件的实例，从而可以直接调用子组件的方法、访问子组件的属性，实现组件之间的通信和协作。
>
>4. 动态组件切换：通过 `ref` 可以控制动态组件的切换，根据条件动态加载不同的组件，实现动态页面的构建。
>
>5. 第三方库集成：在集成第三方库或插件时，有时需要直接访问其底层 DOM 节点或实例对象，这时可以使用 `ref` 来获取对应的引用。
>
>总之，`ref` 提供了一种直接访问和操作元素或组件的方式，可以在需要直接操作 DOM 或组件实例的场景下使用，但需要注意在大部分情况下，应该优先使用 Vue 的数据驱动和组件通信机制，避免过多地使用 `ref`。



## 单向数据流,  子组件不直接对父组件传递的数据进行修改

> 是的，单向数据流的设计目的是为了维护数据的安全性和可预测性。在 Vue 中，数据流是单向的，从父组件向子组件传递数据，子组件不能直接修改父组件的数据。这样的设计有以下几个好处：
>
> 1. 数据安全性：通过限制子组件只能读取父组件传递的数据，可以避免意外修改父组件的数据，确保数据的完整性和一致性。
>
> 2. 可预测性：由于只有父组件可以修改数据，子组件的状态更易于理解和追踪。当数据修改发生时，你可以直接查找到哪个父组件对数据进行了修改。
>
> 3. 组件独立性：通过将数据作为 props 传递给子组件，可以使子组件更加独立和可复用。子组件不依赖于特定的数据来源，可以在不同的上下文中使用，并且父组件的变化不会对子组件产生意外的影响。
>
> 虽然子组件不能直接修改父组件的数据，但是可以通过向父组件发送事件（使用 `$emit` 方法）来通知父组件进行相应的修改。这样可以保持数据的单向流动，同时实现子组件与父组件之间的通信。
>
> 总之，单向数据流的设计有助于提高应用程序的可维护性和可预测性，确保数据的安全性，并促进组件的独立性和复用性。



### **也可以重新定义属性来接收属性，并用副本进行数据返回，而原数据不变**

> 是的，你可以在子组件中通过定义一个新的属性来接收父组件传递的属性，并在子组件内部使用副本来处理数据，从而保持父组件的属性不变。
>
> 这种做法可以确保子组件内部的数据操作不会影响到父组件的原始数据，同时也提供了更大的灵活性和可控性，因为你可以在子组件中对数据进行处理、转换或者衍生出新的数据，而不会对父组件的数据造成影响。
>
> 以下是一个示例：
>
> ```vue
> <template>
>   <div>
>     <p>{{ copiedData }}</p>
>     <button @click="modifyCopiedData">Modify Data</button>
>   </div>
> </template>
> 
> <script>
> export default {
>   props: ['originalData'],
>   data() {
>     return {
>       copiedData: null
>     };
>   },
>   mounted() {
>     this.copiedData = this.originalData; // 使用副本初始化 copiedData
>   },
>   methods: {
>     modifyCopiedData() {
>       // 在子组件内部修改 copiedData，而不会影响 originalData
>       this.copiedData = 'Modified Data';
>     }
>   }
> };
> </script>
> ```
>
> 在上面的示例中，子组件接收父组件传递的 `originalData` 属性，并在 `mounted` 钩子中将其赋值给 `copiedData` 属性，从而创建了一个副本。然后，在子组件内部修改 `copiedData` 的值，而不会对父组件的 `originalData` 造成任何改变。
>
> 这种方式允许你在子组件中独立地操作数据，同时保持父组件的数据不变，以实现更好的数据封装和隔离。



## 标签向子组件传递数据，不加冒号和加冒号的区别

> 在 Vue 中，标签向子组件传递数据时，使用冒号 `:` 进行属性绑定可以实现动态绑定，而不加冒号则表示传递的是静态的属性。
>
> 1. 使用冒号 `:` 进行属性绑定：
> ```html
> <child-component :propName="parentData"></child-component>
> ```
> 这种写法表示将父组件中的 `parentData` 属性的值动态绑定到子组件的 `propName` 属性上。当父组件中的 `parentData` 发生变化时，子组件的 `propName` 属性也会相应更新。
>
> 2. 不使用冒号进行属性绑定：
> ```html
> <child-component propName="staticData"></child-component>
> ```
> 这种写法表示将一个静态的属性值 "staticData" 直接传递给子组件的 `propName` 属性。无论父组件中的数据如何变化，子组件的 `propName` 属性始终保持为 "staticData"。
>
> 总结：
> 使用冒号 `:` 进行属性绑定能够实现动态绑定，使子组件能够响应父组件中数据的变化。而不使用冒号则表示传递的是静态属性，子组件的属性值将保持不变。根据具体需求，选择适合的方式进行属性传递。



## 子组件的属性值将保持不变请给出示例，并指出哪里不变



> 假设有一个父组件和一个子组件，父组件向子组件传递一个静态的属性值 "**staticData**"，并在子组件中进行展示。在子组件中，我们可以通过计算属性将传递的属性值展示出来
>
> 父组件：
> ```html
> <template>
>   <div>
>     <child-component propName="staticData"></child-component>
>   </div>
> </template>
> ```
>
> 子组件：
> ```html
> <template>
>   <div>
>     <p>{{ computedProp }}</p>
>   </div>
> </template>
> 
> <script>
> export default {
>   props: ['propName'],
>   computed: {
>     computedProp() {
>       return this.propName;
>     }
>   }
> }
> </script>
> ```
>
> 在这个例子中，父组件向子组件传递的属性值 "staticData" 是静态的，即在父组件中定义时就确定了，不会随着父组件的变化而改变。子组件接收到该属性后，在计算属性 `computedProp` 中将其展示出来。
>
> 即使在父组件中更改了属性的值，子组件接收到的值仍然是最初传递的 "staticData"，它不会随着父组件的变化而改变。这就是在不使用冒号进行属性绑定时，子组件的属性值保持不变的情况



## 动态绑定加冒号后，如果”12“，引号内部为数字的话会传递子组件时是数字

>
>
>在 Vue 中，使用冒号 `:` 进行动态绑定时，属性值会被解析为 JavaScript 表达式。如果引号内部为数字，它会被解析为一个数字类型，而不是字符串类型。
>
>例如，考虑以下代码：
>
>父组件：
>```html
><template>
>  <div>
>    <child-component :propName="12"></child-component>
>  </div>
></template>
>```
>
>子组件：
>```html
><template>
>  <div>
>    <p>{{ typeof propName }}: {{ propName }}</p>
>  </div>
></template>
>
><script>
>export default {
>  props: ['propName']
>}
></script>
>```
>
>在这个例子中，父组件向子组件动态绑定了属性 `propName`，值为 `12`。在子组件中，我们通过 `typeof` 运算符获取到 `propName` 的类型，并展示在模板中。
>
>当渲染子组件时，输出将是 `number: 12`，表示 `propName` 是一个数字类型的属性值。
>
>这是因为在动态绑定时，Vue 会对表达式进行求值，将其解析为实际的 JavaScript 类型。因此，如果你在引号内部传递的是一个数字，它会被解析为数字类型而不是字符串类型。



## props特性和非props特性的区别

> 在 Vue 中，组件的属性可以分为两类：props 特性和非 props 特性。
>
> 1. Props 特性：
>    - Props 特性是通过在组件上声明 `props` 选项来定义的。它用于接收父组件传递的数据，并在子组件中使用。
>    - Props 特性是响应式的，即当父组件的数据发生变化时，子组件会自动更新相应的 props 数据。
>    - Props 特性是单向数据流的，只能由父组件向子组件传递数据，子组件不能直接修改 props 的值。
>    - Props 特性可以定义默认值和类型验证，以确保接收到的数据符合预期。
>
> 2. 非 Props 特性：
>    - 非 Props 特性是指在组件上使用的除了 props 之外的其他属性。
>    - 非 Props 特性不会自动响应数据的变化，它们只是被传递给组件，组件可以直接使用这些属性，但不会与父组件的数据保持关联。
>    - 非 Props 特性可以用于传递事件、样式、类名等信息给子组件，但不会像 props 一样触发子组件的更新。
>
> 总结：
> Props 特性用于父子组件之间的数据传递，是单向且响应式的，具有类型验证和默认值的特性。非 Props 特性则是一种直接传递信息给子组件的方式，但不会触发子组件的更新。两者在用途和特性上有明显的区别，应根据需求选择适合的方式来传递数据和信息。



### 非pros元素会在dom上显示



>非 props 特性会在 DOM 上显示，而 props 特性不会直接在 DOM 上显示。 
>
>非 props 特性是指在组件标签上使用的除了 props 之外的属性，例如 `class`、`style`、`id`、`data-*` 等。这些属性会直接应用到组件所对应的 DOM 元素上，从而影响组件的样式、行为或其他方面的展示。
>
>举个例子，假设有一个自定义的 `<my-component>` 组件，除了接收 `text` 这个 props，还有一个非 props 特性 `color`。在使用组件的时候，可以这样写：
>
>```html
><my-component text="Hello" color="red"></my-component>
>```
>
>在渲染时，`text` 会作为 props 传递给子组件，而 `color` 则会直接应用到组件所对应的 DOM 元素上，如 `<div>` 或其他元素。在这个例子中，`<my-component>` 的 DOM 元素会有 `style="color: red;"` 的属性，从而将文本显示为红色。
>
>需要注意的是，非 props 特性的值在组件内部是无法直接访问的，它们只是影响组件渲染时的表现，但不会成为组件实例的属性。





## validator的实用场景

 

> 自定义验证器在 Vue 组件中的 props 验证中非常有用。它允许你对传递给组件的 prop 值进行自定义的验证逻辑，以确保数据的准确性和完整性。
>
> 以下是一些自定义验证器的实用场景示例：
>
> 1. 数据类型验证：你可以使用自定义验证器来验证传递给 prop 的数据类型是否符合预期。例如，你可以验证一个 prop 是否为字符串、数字、布尔值等特定的数据类型。
>
> 2. 数据范围验证：你可以使用自定义验证器来验证传递给 prop 的数据是否在指定的范围内。例如，你可以验证一个数字 prop 是否在特定的最小值和最大值之间。
>
> 3. 数据格式验证：你可以使用自定义验证器来验证传递给 prop 的数据是否符合特定的格式要求。例如，你可以验证一个日期 prop 是否符合特定的日期格式。
>
> 4. 依赖关系验证：你可以使用自定义验证器来验证传递给 prop 的数据与其他 prop 或组件的状态之间的依赖关系。例如，你可以验证两个相关的 prop 是否一起存在或符合特定的条件。
>
> 自定义验证器允许你根据项目的需求添加额外的验证逻辑，确保传递给组件的数据满足特定的要求。这样可以提高代码的可靠性和健壮性，防止不正确或不合法的数据进入组件。





### validator的主要作用

>
>
>验证器的主要作用是在组件接收到 prop 数据时对其进行验证，并提供错误提示，以便开发人员在开发和调试过程中发现潜在的数据传输错误。验证器可以用于检查数据的类型、范围、格式以及其他自定义规则，并通过抛出错误或返回布尔值的方式指示是否通过验证。
>
>验证器通常用于提醒开发人员有关传递给组件的数据是否满足预期，并帮助他们识别和修复潜在的问题。验证器本身并不执行实际的数据操作，而是用于验证数据的正确性和完整性。
>
>然而，开发人员可以在验证器中执行一些额外的操作，例如数据转换、数据处理或触发其他逻辑。这取决于具体的业务需求和验证器的设计。验证器的主要目的是确保传递给组件的数据满足预期，并提供反馈和错误提示，以便开发人员能够进行必要的调整和修正。



##  自定义事件和原生事件

>

自定义事件和原生事件是两种不同类型的事件。

1. 自定义事件：自定义事件是在 Vue 组件中定义的事件，它们用于组件内部的通信和交互。通过使用 `$emit` 方法在子组件中触发自定义事件，父组件可以通过在子组件上使用 `v-on` 或 `@` 来监听和响应这些事件。自定义事件的使用可以方便组件之间的通信和数据传递。

   例如，在子组件中可以使用 `$emit` 触发一个自定义事件：
   ```vue
   // 子组件
   <template>
     <button @click="$emit('custom-event', data)">Click me</button>
   </template>
   ```
   然后在父组件中监听该自定义事件：
   ```vue
   // 父组件
   <template>
     <child-component @custom-event="handleCustomEvent"></child-component>
   </template>
   <script>
   export default {
     methods: {
       handleCustomEvent(data) {
         // 处理自定义事件的回调逻辑
       }
     }
   }
   </script>
   ```

2. 原生事件：原生事件是由浏览器提供的常规事件，例如点击、滚动、键盘输入等。在 Vue 中，可以使用 `v-on` 或 `@` 来监听和响应原生事件。

   例如，在父组件中监听一个原生的 `click` 事件：
   ```vue
   // 父组件
   <template>
     <button @click="handleClick">Click me</button>
   </template>
   <script>
   export default {
     methods: {
       handleClick() {
         // 处理点击事件的回调逻辑
       }
     }
   }
   </script>
   ```

总结：自定义事件主要用于组件内部的通信，而原生事件主要用于响应浏览器提供的常规事件。它们在使用方式和应用场景上有一些区别，但都可以用于处理交互和响应用户操作。



### 自定义事件+.native变成原生事件>

>
>
>在 Vue 中，可以通过添加 `.native` 修饰符将自定义事件转换为原生事件。
>
>当你在父组件中使用 `v-on` 或 `@` 监听一个自定义事件时，添加 `.native` 修饰符可以使该事件成为一个原生事件。这样就可以在父组件中监听到子组件触发的原生事件。
>
>例如，在子组件中定义一个自定义事件 `custom-event`，然后在父组件中将其转换为原生事件：
>```vue
><!-- 子组件 -->
><template>
>  <button @click="$emit('custom-event')">Click me</button>
></template>
>```
>
>```vue
><!-- 父组件 -->
><template>
>  <child-component @custom-event.native="handleNativeEvent"></child-component>
></template>
><script>
>export default {
>  methods: {
>    handleNativeEvent(event) {
>      // 处理子组件触发的原生事件
>    }
>  }
>}
></script>
>```
>
>在上面的例子中，父组件使用 `@custom-event.native` 监听子组件触发的 `custom-event` 事件，并在 `handleNativeEvent` 方法中处理该事件。
>
>通过添加 `.native` 修饰符，Vue 会将自定义事件转换为与原生事件相同的方式进行处理，从而使父组件能够捕获到子组件触发的原生事件。



### 如果不加.native，只能由子组件进行emit触发是吗

>
>
>是的，如果在父组件中没有使用 `.native` 修饰符监听自定义事件，那么该事件只能由子组件通过 `$emit` 方法触发，并且只能在子组件的作用域内进行监听。
>
>在这种情况下，父组件无法直接捕获子组件触发的自定义事件，而是需要在子组件内部使用 `$emit` 触发事件，并在子组件内部或其父组件中进行相应的处理。
>
>```vue
><!-- 子组件 -->
><template>
>  <button @click="handleClick">Click me</button>
></template>
><script>
>export default {
>  methods: {
>    handleClick() {
>      this.$emit('custom-event');
>    }
>  }
>}
></script>
>```
>
>```vue
><!-- 父组件 -->
><template>
>  <child-component @custom-event="handleCustomEvent"></child-component>
></template>
><script>
>export default {
>  methods: {
>    handleCustomEvent() {
>      // 处理子组件触发的自定义事件
>    }
>  }
>}
></script>
>```
>
>在上述示例中，子组件通过 `handleClick` 方法触发自定义事件 `custom-event`，然后父组件使用 `@custom-event` 监听该事件，并在 `handleCustomEvent` 方法中处理它。
>
>所以，如果你想要父组件能够捕获到子组件触发的事件，可以选择使用 `.native` 修饰符将自定义事件转换为原生事件。否则，事件只能由子组件通过 `$emit` 方法触发。



## 非父子组件传值方法

>
>
>在 Vue 中，非父子组件之间传值可以通过以下几种方式实现：
>
>1. 使用事件总线（Event Bus）：创建一个全局的 Vue 实例，用于充当中央事件总线，通过该实例进行事件的派发和监听，从而实现组件间的通信。
>
>```javascript
>// 创建事件总线实例
>const bus = new Vue();
>
>// 在发送方组件中触发事件
>bus.$emit('event-name', data);
>
>// 在接收方组件中监听事件
>bus.$on('event-name', data => {
>  // 处理接收到的数据
>});
>```
>
>2. 使用 Vuex：Vuex 是 Vue 官方提供的状态管理库，用于集中管理应用程序的状态。通过在 Vuex 中定义和修改状态，不同组件可以共享和访问这些状态数据。
>
>```javascript
>// 在 Vuex 中定义状态
>const store = new Vuex.Store({
>  state: {
>    data: ''
>  },
>  mutations: {
>    updateData(state, payload) {
>      state.data = payload;
>    }
>  }
>});
>
>// 在发送方组件中触发状态更新
>this.$store.commit('updateData', data);
>
>// 在接收方组件中获取状态数据
>computed: {
>  data() {
>    return this.$store.state.data;
>  }
>}
>```
>
>3. 使用第三方状态管理库：除了 Vuex，还有其他一些第三方状态管理库可以用于非父子组件间的数据传递，如 Vue-Observe-Visibility、Vue-Bus、Vue-Event-Proxy 等。
>
>这些方法都可以实现非父子组件之间的数据传递和通信，选择哪种方式取决于你的具体需求和项目规模。



### 总线模式

>
>
>事件总线模式（Event Bus Pattern）是一种在 Vue 中实现非父子组件通信的常用方式。它通过创建一个全局的 Vue 实例作为中央事件总线，用于组件之间的事件派发和监听。
>
>下面是使用事件总线模式的步骤：
>
>1. 创建事件总线实例：在你的应用程序中，创建一个全局的 Vue 实例作为事件总线。
>
>```javascript
>// main.js 或其他入口文件
>import Vue from 'vue';
>
>// 创建事件总线实例
>export const bus = new Vue();
>```
>
>2. 在发送方组件中触发事件：在发送方组件中，使用事件总线实例的 `$emit` 方法触发自定义事件，并传递需要传递的数据。
>
>```javascript
>import { bus } from './main';
>
>// 在发送方组件中触发事件
>bus.$emit('event-name', data);
>```
>
>3. 在接收方组件中监听事件：在接收方组件中，使用事件总线实例的 `$on` 方法监听事件，并处理接收到的数据。
>
>```javascript
>import { bus } from './main';
>
>// 在接收方组件中监听事件
>bus.$on('event-name', data => {
>  // 处理接收到的数据
>});
>```
>
>通过事件总线模式，不同组件之间可以通过事件进行解耦的通信。任何一个组件都可以成为发送方或接收方，只需要使用相同的事件名称进行绑定即可。
>
>需要注意的是，事件总线是一个全局的实例，因此请确保命名事件名称的唯一性，以避免命名冲突。另外，由于事件总线是一个全局实例，不适合在大型应用中频繁使用，因为过多的全局事件可能会导致代码可读性和维护性的问题。在这种情况下，可以考虑使用状态管理库如 Vuex 来进行更强大和可预测的状态管理。



### 总线模式原理

通过创建一个全局的 Vue 实例作为事件总线，所有组件共享该实例。

在创建事件总线时，我们使用 `new Vue()` 创建了一个全局的 Vue 实例 `bus`，并将其导出，使其他组件能够访问它。这个 `bus` 实例并不是 Vue 原型链上的一个特殊对象，而是一个普通的 Vue 实例。

因为 `bus` 是一个 Vue 实例，所以它具有 Vue 实例的常用方法，包括 `$emit` 和 `$on`。通过 `$emit` 方法，我们可以在任何组件中触发自定义事件，并通过 `$on` 方法在其他组件中监听和处理这些事件。

当一个组件触发了自定义事件并通过 `bus.$emit` 发送数据时，其他组件通过 `bus.$on` 来监听相同的事件，并在事件被触发时执行相应的回调函数。

总结起来，事件总线模式是通过创建一个全局的 Vue 实例作为事件中心，使所有组件都可以访问和使用该实例，从而实现组件间的非父子通信。这种通信方式不依赖于原型链，而是利用共享的事件总线实例进行数据的传递和监听。



### 回调函数 this指向

var this_ = this;          this.bus.$on("change", function (msg) {            this_.selfContent = msg;

>
>
>是的，这种情况下需要使用变量来保存 `this` 的引用，因为在回调函数中，`this` 的指向会发生改变。
>
>在 Vue 的生命周期钩子函数（如 `mounted`）中，`this` 指向的是当前组件实例，但在回调函数内部，`this` 的指向会根据函数的执行上下文而改变，可能指向其他对象或者是 `undefined`。
>
>为了解决这个问题，可以在外部使用一个变量（如 `this_`）来保存 `this` 的引用，然后在回调函数中使用该变量来访问当前组件实例的属性或方法。
>
>这样做是因为 JavaScript 中的函数作用域和执行上下文的特性导致的，通过保存 `this` 的引用，可以在回调函数内部正确地访问到组件实例的成员。



### 使用挂载函数监听 总线上的信息的好处

>使用挂载函数（如 `mounted`）来监听总线上的信息的好处是可以确保在组件实例已经被完全挂载到 DOM 上之后再进行监听。这样可以避免在组件还未完全初始化或挂载到 DOM 上时就进行事件监听，确保监听的准确性和有效性。
>
>具体的好处包括：
>
>1. 可以确保组件已经完成初始化和挂载，避免监听到不完整或不准确的数据。
>2. 可以确保组件的 DOM 元素已经存在，可以正确地处理事件绑定和操作 DOM 元素。
>3. 在挂载函数中进行监听，可以提高代码的可读性和维护性，因为监听总线的代码会集中在一个特定的生命周期钩子中，方便查找和管理。
>
>总的来说，使用挂载函数来监听总线上的信息可以确保监听的时机是在组件已经准备就绪的情况下，可以更可靠地处理数据和事件。



### 在挂载函数添加监听器后， 组件能实时监听信息是吗

>是的，当在挂载函数中添加监听器后，组件能够实时监听信息的变化。这意味着当总线上的信息发生变化时，监听器会立即执行相应的回调函数，从而更新组件的状态或执行其他操作。
>
>通过在挂载函数中添加监听器，你可以确保组件在挂载后就开始监听信息，从而实现实时更新。这在需要根据总线上的信息来动态更新组件状态或执行相应操作的情况下非常有用。



## 插槽slot是给父组件标签的占位符吗



是的，插槽（slot）可以被认为是父组件中为子组件提供的占位符。它允许父组件在使用子组件时，向子组件传递一些内容，并在子组件内部进行展示。

通过使用插槽，父组件可以在子组件的特定位置插入自定义的内容，从而实现灵活的组件复用和定制化。父组件可以在插槽中放置文本、HTML标记、其他组件甚至是动态生成的内容，而这些内容将被子组件接收并在对应位置进行渲染。

插槽为组件提供了一种灵活的方式来自定义其内容，让父组件能够对子组件进行更多的定制和扩展。



### 插槽与具名插槽

插槽： 父组件被渲染标签 内部所包含的信息， 可保留并取代于子标签内部 插槽位置， 如果不对标签及插槽进行命名， 则多个标签对应一个插槽位置

具名标签： 通过对标签及插槽进行命名， 可实现具体标签 对应 具体插槽 ， 对标签进行分类放置于 子组件所渲染的dom 元素上



 

### 插槽实例

>
>
>当父组件中使用子组件，并为子组件提供插槽时，可以这样定义和使用：
>
>父组件模板：
>```html
><template>
>  <div>
>    <h2>父组件</h2>
>    <child-component>
>      <p>这是插槽的内容</p>
>      <span>这也是插槽的内容</span>
>    </child-component>
>  </div>
></template>
>```
>
>子组件模板：
>```html
><template>
>  <div>
>    <h3>子组件</h3>
>    <slot></slot>
>  </div>
></template>
>```
>
>在上述示例中，父组件通过`<child-component>`标签使用了子组件，并在标签内部提供了插槽的内容。子组件通过`<slot></slot>`标签定义了插槽的位置。
>
>最终渲染结果会是父组件中的插槽内容被放置在子组件的插槽位置，如下所示：
>```html
><div>
>  <h2>父组件</h2>
>  <div>
>    <h3>子组件</h3>
>    <p>这是插槽的内容</p>
>    <span>这也是插槽的内容</span>
>  </div>
></div>
>```
>
>可以看到，父组件通过插槽向子组件传递了自定义的内容，并且这些内容被子组件在插槽位置进行了渲染。这样的方式使得子组件可以根据不同的父组件使用场景来展示不同的内容，实现了灵活的组件复用和定制化。



### 具名插槽实例

>
>
>具名插槽（Named Slots）是 Vue 中一种更灵活的插槽方式，它允许父组件在子组件中定义多个具名插槽，并向这些插槽提供具体的内容。
>
>具名插槽通过在子组件中使用 `<slot>` 标签并设置 `name` 属性来定义，然后在父组件中使用 `<template>` 标签的 `v-slot` 指令来向具名插槽提供内容。
>
>下面是一个示例，展示了具名插槽的使用：
>
>```html
><!-- 子组件模板 -->
><template>
>  <div>
>    <h3>子组件</h3>
>    <slot name="header"></slot>
>    <slot></slot>
>    <slot name="footer"></slot>
>  </div>
></template>
>
><!-- 父组件模板 -->
><template>
>  <div>
>    <h2>父组件</h2>
>    <child-component>
>      <template v-slot:header>
>        <p>这是头部插槽的内容</p>
>      </template>
>      <p>这是默认插槽的内容</p>
>      <template v-slot:footer>
>        <p>这是底部插槽的内容</p>
>      </template>
>    </child-component>
>  </div>
></template>
>```
>
>在子组件中，使用 `<slot>` 标签并设置 `name` 属性来定义具名插槽。在父组件中，使用 `<template>` 标签和 `v-slot` 指令来向具名插槽提供具体的内容。
>
>注意，在父组件中使用 `<template>` 标签时，可以使用 `v-slot` 或者 `slot` 属性来指定具名插槽的名称，如 `v-slot:header` 或者 `slot="header"`。
>
>通过使用具名插槽，父组件可以更精确地控制子组件内不同插槽的内容，从而实现更灵活的组件组合和渲染。





### 插槽解决：

​	**如果不使用插槽会导致父组件被渲染标签内部信息被覆盖**

>是的，如果不使用插槽，在父组件的被渲染标签内部的内容将会被子组件的模板完全覆盖。
>
>当父组件使用子组件时，子组件的模板会完全替换父组件标签的内容，而不会保留父组件标签内部原有的内容。这可能导致父组件的信息被覆盖或丢失。
>
>使用插槽可以解决这个问题，因为插槽提供了一种灵活的方式，允许父组件在子组件的特定位置插入内容，而不会覆盖子组件的模板。通过使用插槽，可以保留父组件被渲染标签内部的内容，并与子组件的模板进行组合显示。
>
>因此，如果需要在子组件中保留父组件被渲染标签内部的内容，应该使用插槽来定义和使用子组件，以确保父组件的信息不会被覆盖。



# 6.14  14:10



## 作用域插槽

> Vue 的作用域插槽（Scoped Slots）是一种特殊的插槽类型，允许父组件向子组件传递可复用的模板内容，并在子组件中根据自己的数据进行渲染。
>
> 作用域插槽的主要目的是允许子组件在父组件的上下文中使用插槽内容，并且可以访问父组件的数据。这样，子组件可以根据自己的数据对插槽内容进行个性化的渲染。
>
> 使用作用域插槽时，父组件可以将数据传递给子组件，并通过插槽的方式将数据暴露给父组件。子组件在渲染插槽内容时，可以使用这些数据进行个性化的渲染。
>
> 以下是使用作用域插槽的示例：
>
> 父组件模板：
> ```html
> <div id="app">
>   <child>
>     <template v-slot:default="slotProps">
>       <span>{{ slotProps.message }}</span>
>     </template>
>   </child>
> </div>
> ```
>
> 子组件模板：
> ```html
> <template>
>   <div>
>     <slot :message="message"></slot>
>   </div>
> </template>
> 
> <script>
> export default {
>   data() {
>     return {
>       message: 'Hello from child component',
>     };
>   },
> };
> </script>
> ```
>
> 在上述示例中，父组件通过 `v-slot:default` 定义了一个作用域插槽，并将 `slotProps` 作为参数接收插槽数据。子组件使用 `slot` 元素定义了一个匿名插槽，并通过 `:message` 将数据传递给插槽内容。
>
> 当父组件渲染时，插槽内容将被渲染为 `<span>Hello from child component</span>`，并显示在父组件的 DOM 中。
>
> 作用域插槽允许父组件向子组件传递更灵活的模板内容，并在子组件中进行个性化的渲染，提供了更强大的组件组合能力。





## v-once与动态组件

动态组件: 通过动态改变组件名 来实现组件的动态渲染。当切换组件时，Vue 会销毁之前渲染的组件实例，并创建新的组件实例进行渲染。

当你使用动态组件切换时，旧组件会被销毁，即它的生命周期钩子会被调用，包括 `beforeDestroy` 和 `destroyed`。同时，Vue 会创建并渲染新的组件实例，它会经历创建、挂载和更新的生命周期过程。

这种动态切换组件的机制允许你在应用中灵活地根据条件渲染不同的组件，并且在切换时可以执行相应的销毁和初始化操作。这样可以确保组件在切换时的状态和数据是完全独立和隔离的，避免潜在的数据混乱和冲突。

因此，使用动态组件切换时，原组件会被销毁并重新创建新的组件实例。这样可以确保组件之间的状态和数据是独立的，避免可能的冲突和问题。

>
>
>动态组件和`v-once`指令是 Vue.js 中的两个不同的特性。
>
>1. 动态组件：动态组件允许根据组件的名称动态地渲染不同的组件。你可以使用特殊的 `<component>` 元素，并通过 `is` 属性来指定要渲染的组件名称。这样，根据不同的条件或用户操作，可以动态地切换显示不同的组件。
>
>   示例：
>   ```html
>   <component :is="componentName"></component>
>   ```
>
>   在上述示例中，`componentName` 是一个动态的组件名称，可以根据需要进行更改。
>
>2. `v-once`指令：`v-once`指令用于将元素或组件标记为只渲染一次，即在首次渲染后不再更新。一旦使用了`v-once`指令，元素或组件的内容将被缓存，并且不会再随后的数据变化而重新渲染。这对于静态内容或不需要频繁更新的内容非常有用，可以提高渲染性能。
>
>   示例：
>   ```html
>   <div v-once>{{ staticContent }}</div>
>   ```
>
>   在上述示例中，`staticContent` 是一个静态的内容，使用了`v-once`指令，确保它只会渲染一次，并且不会再随后的数据变化而更新。
>
>这两个特性在不同的场景下有不同的用途。动态组件用于根据条件或用户操作动态渲染不同的组件，而`v-once`指令用于将内容标记为只渲染一次，提高渲染性能。





### v-once标记的组件不会因为 v-if而销毁是吗

>
>
>对的，使用 `v-once` 标记的组件不会因为 `v-if` 指令的条件切换而销毁和重新创建。当使用 `v-once` 标记一个组件时，它会在首次渲染时被渲染并缓存，之后的更新中会跳过该组件的重新渲染。
>
>这意味着，如果一个组件被标记为 `v-once` 并且当前处于显示状态（`v-if` 条件为 `true`），那么无论后续 `v-if` 条件如何变化，该组件都不会被销毁和重新创建。它会保持在DOM中，仅在首次渲染时进行渲染，后续更新中会保持不变。
>
>这种行为可以提高性能，因为跳过不必要的组件销毁和重新创建过程，只进行数据的更新。然而，需要注意的是，`v-once` 标记的组件在条件不满足时仍然会保留在DOM中，可能占用一定的内存和资源。因此，在使用 `v-once` 时需要谨慎考虑是否需要保留这些组件，避免出现不必要的内存占用。
>
>总结起来，`v-once` 标记的组件在条件切换时不会被销毁，仅在首次渲染时进行渲染，后续更新中会保持不变。



### v-once

是的，使用 `v-if` 条件渲染时，如果条件为 `false`，Vue 会将该组件从 DOM 中移除，并将其销毁。当条件再次为 `true` 时，Vue 会重新生成该组件并插入到 DOM 中。

当使用 `v-once` 标记的组件被移除后，下次重新生成时，Vue 会直接使用之前缓存的静态 VNode，而不需要重新计算和渲染组件内容。这意味着组件的内容会被快速地展示，而不需要再次渲染生成。

因此，通过结合使用 `v-if` 和 `v-once`，可以在满足条件时生成组件并进行缓存，以便在下次条件满足时快速展示，并避免重新渲染和计算组件内容。这样可以提高性能和渲染效率。



## transition标签 (内部类名)

> `<transition>` 是 Vue 提供的内置组件，用于在元素的插入或移除过程中应用过渡效果。它可以用来实现动画效果或平滑地过渡元素的出现和消失。
>
> `<transition>` 组件可以包裹要过渡的元素，并使用不同的 CSS 类名来触发过渡效果。它包含以下属性和使用方式：
>
> - `name`：指定过渡的名称，可以用于定义过渡效果的 CSS 类名，默认为 `"v"`。
> - `appear`：指定是否在初始渲染时就应用过渡效果，默认为 `false`。
> - `appear-class`：指定初始渲染时应用的 CSS 类名。
> - `appear-to-class`：指定初始渲染过渡结束时应用的 CSS 类名。
> - `appear-active-class`：指定初始渲染过渡过程中应用的 CSS 类名。
> - `enter-class`：指定插入过渡开始时应用的 CSS 类名。
> - `enter-to-class`：指定插入过渡结束时应用的 CSS 类名。
> - `enter-active-class`：指定插入过渡过程中应用的 CSS 类名。
> - `leave-class`：指定移除过渡开始时应用的 CSS 类名。
> - `leave-to-class`：指定移除过渡结束时应用的 CSS 类名。
> - `leave-active-class`：指定移除过渡过程中应用的 CSS 类名。
>
> 使用 `<transition>` 组件的示例代码如下：
>
> ```html
> <transition name="fade" appear>
>   <p v-if="show">Hello, Vue!</p>
> </transition>
> ```
>
> 在上面的代码中，我们定义了一个名为 `"fade"` 的过渡效果，并将其应用于 `<transition>` 组件包裹的 `<p>` 元素。当 `show` 的值为 `true` 时，`<p>` 元素会以渐变的方式显示出来；当 `show` 的值为 `false` 时，`<p>` 元素会以渐变的方式消失。
>
> 你可以通过在 CSS 样式中定义相应的过渡类名来实现具体的过渡效果，例如：
>
> ```css
> .fade-enter-active, .fade-leave-active {
>   transition: opacity 0.5s;
> }
> 
> .fade-enter, .fade-leave-to {
>   opacity: 0;
> }
> ```
>
> 上面的 CSS 样式中定义了淡入淡出的过渡效果，其中 `.fade-enter-active` 和 `.fade-leave-active` 控制过渡的持续时间和属性，`.fade-enter` 和 `.fade-leave-to` 控制过渡的起始和结束状态。
>
> 通过 `<transition>` 组件的使用，你可以轻松地为元素添加过渡效果，使页面更加生动和流畅。



vue_27代码解析

>
>
>这段代码使用了 Vue.js 的过渡效果和动画特性。下面是代码的解析：
>
>1. `@keyframes bounce-in` 定义了一个名为 `bounce-in` 的关键帧动画。它在动画过程中使用了三个关键帧：
>   - 在 0% 的关键帧，元素的缩放比例为 0。
>   - 在 50% 的关键帧，元素的缩放比例为 1.5。
>   - 在 100% 的关键帧，元素的缩放比例恢复为 1。
>
>2. `.active` 类选择器用于定义进入过渡的元素状态。它指定了元素的变换原点为左侧中心，并且应用了 `bounce-in` 动画，持续时间为 1 秒。
>
>3. `.leave` 类选择器用于定义离开过渡的元素状态。它指定了元素的变换原点为左侧中心，并且应用了反向的 `bounce-in` 动画，持续时间为 1 秒。
>
>4. `<transition>` 组件包裹了一个条件渲染的 `<div>` 元素。根据 `v-if="show"` 的值，这个 `<div>` 元素会根据条件进行进入或离开的过渡动画。
>
>5. `enter-active-class="active"` 指定了进入过渡的元素在过渡期间应用的类名为 `active`，从而触发相应的动画效果。
>
>6. `leave-active-class="leave"` 指定了离开过渡的元素在过渡期间应用的类名为 `leave`，从而触发相应的动画效果。
>
>7. `<button>` 元素绑定了 `@click` 事件，当点击按钮时会调用 `handleClick` 方法。
>
>8. `handleClick` 方法在每次点击按钮时切换 `show` 数据的值，从而触发条件渲染的过渡效果。
>
>综上所述，这段代码实现了一个简单的过渡效果，通过点击按钮切换元素的显示和隐藏，并应用了定义的关键帧动画效果。



总结： active 和leave 是设置过渡时期的状态参数， v-if设置此元素的存在与否， 过程使用 动画- 淡入淡出 - 变大缩小 - 提高用户体验





## @keyframes



> `@keyframes` 是 CSS 中用于定义关键帧动画的规则。它允许您指定元素在动画过程中的不同状态，并定义每个状态的样式属性。
>
> 具体来说，`@keyframes` 规则允许您定义一个或多个关键帧，每个关键帧表示动画的某个特定状态。在每个关键帧中，您可以设置元素的样式属性，例如位置、尺寸、颜色、透明度等。通过在关键帧之间定义过渡效果，浏览器会自动计算并呈现中间的过渡帧，从而创建平滑的动画效果。
>
> `@keyframes` 的语法如下：
>
> ```css
> @keyframes animation-name {
>   keyframe-selector-1 {
>     /* 样式属性 */
>   }
>   keyframe-selector-2 {
>     /* 样式属性 */
>   }
>   /* 更多关键帧 */
> }
> ```
>
> - `animation-name`：为动画定义一个名称，您可以在后面的 CSS 规则中引用它。
> - `keyframe-selector`：表示动画的某个关键帧，可以使用百分比或关键词（如 `from` 和 `to`）指定关键帧的位置。
>
> 在 `keyframe-selector` 中，您可以设置元素在该关键帧时的样式属性。通过定义不同的关键帧和属性值，您可以创建从一个状态到另一个状态的平滑过渡效果。
>
> 在示例代码中的 `@keyframes bounce-in` 规则中，定义了三个关键帧，分别是 0%、50% 和 100%。每个关键帧设置了不同的缩放比例，从而实现元素从无到放大再到正常大小的弹跳效果。通过应用这个关键帧动画，您可以为元素创建一个自定义的动画效果。
>
> 总结来说，`@keyframes` 规则提供了一种定义关键帧动画的方式，让您可以精确控制元素在动画过程中的不同状态和样式，从而实现各种各样的动画效果。



## Velocity.js （轻量级的 JavaScript 动画库



> Velocity.js 是一个轻量级的 JavaScript 动画库，用于创建流畅的动画效果。它提供了一组简单易用的 API，可以用来控制元素的属性变化，例如位置、大小、颜色等，从而实现各种动画效果。
>
> Velocity.js 具有以下特点：
>
> 1. 性能优化：Velocity.js 通过使用原生 JavaScript 动画引擎，避免了使用 CSS 过渡和动画的性能开销，使得动画更加流畅。
> 2. 功能强大：Velocity.js 支持丰富的动画选项和方法，可以实现各种复杂的动画效果，如缓动动画、序列动画、循环动画等。
> 3. 轻量级：Velocity.js 的文件大小相对较小，压缩后仅约 14KB，因此加载和使用都非常快捷。
>
> 使用 Velocity.js，你可以通过选择器选择需要进行动画的元素，并使用链式调用来定义动画的属性和选项。例如，你可以使用以下代码使用 Velocity.js 实现一个简单的动画：
>
> ```javascript
> Velocity(document.getElementById('myElement'), {
>   opacity: 0.5,
>   translateX: '200px'
> }, {
>   duration: 1000,
>   easing: 'easeOutQuad',
>   complete: function() {
>     console.log('Animation complete');
>   }
> });
> ```
>
> 上述代码会将 `myElement` 元素的透明度设置为 0.5，并沿 X 轴向右平移 200 像素，动画持续时间为 1 秒，并且使用 `easeOutQuad` 缓动函数进行动画。动画完成后，会执行回调函数输出 "Animation complete"。
>
> 总而言之，Velocity.js 是一个功能强大且易于使用的 JavaScript 动画库，适用于创建各种动态效果的网页和应用程序。



## `<transition>` 组件的 `mode` 属性

mode: in-out ,  新元素先进入， 再隐藏旧元素

mode: out-in ,   先隐藏旧元素， 再进入新元素

默认的为 -  in-out模式





# 6.15  12:00

## vueCli

> Vue CLI 是一个由 Vue.js 团队开发的命令行工具，用于快速搭建和管理 Vue.js 项目的工具集合。它提供了一套标准化的**工程化脚手架**，帮助开发者快速初始化、开发和构建 Vue.js 项目。
>
> Vue.js 是一个流行的 JavaScript 前端框架，用于构建用户界面。它采用了基于组件的开发方式，使得构建交互性的单页面应用（Single-Page Application）变得更加简单和高效。Vue.js 具有轻量级、灵活性和易用性等特点，广泛应用于现代的 Web 开发。
>
> Vue CLI 作为 Vue.js 的官方脚手架工具，它的主要功能包括：
>
> 1. 快速创建项目：Vue CLI 提供了一个命令来初始化新的 Vue 项目，自动生成基本的项目结构和配置文件。
>
> 2. 开发服务器：Vue CLI 集成了一个开发服务器，可以在开发过程中自动编译和热重载代码，并支持在多个浏览器中同步查看应用程序。
>
> 3. 插件系统：Vue CLI 支持插件系统，可以通过插件扩展和定制项目的功能，例如添加路由、状态管理等。
>
> 4. 集成构建和打包工具：Vue CLI 集成了现代化的构建工具（如 webpack）和打包工具，帮助开发者优化项目代码，减少文件大小，并生成可部署的生产版本。
>
> 总之，Vue CLI 是一个用于创建、开发和构建 Vue.js 项目的命令行工具，它简化了 Vue.js 项目的搭建和开发流程，提供了一套标准化的工程化脚手架，并与现代化的构建工具集成，使得开发者能够更加高效地开发 Vue.js 应用程序。



### 脚手架理解为应用吗， 比如vueCLi相当于一个应用，管理vue项目，自动配置vue项目

是的，你可以将脚手架理解为一个应用程序，用于管理特定类型的项目的创建、配置和维护。

Vue CLI 就是一个脚手架工具，它专门用于管理 Vue.js 项目。通过 Vue CLI，你可以轻松创建新的 Vue 项目，并提供了许多开箱即用的特性和配置选项。

Vue CLI 提供了一个命令行界面，使你可以使用命令行交互式地创建和管理 Vue 项目。它可以自动设置基本的项目结构、配置文件和依赖项，并提供了开发服务器、构建工具、单元测试工具等功能，帮助你更高效地开发 Vue 应用程序。

除了自动生成项目的基本结构和配置外，Vue CLI 还提供了插件系统，允许你根据需求添加和管理各种插件，扩展项目的功能和能力。这些插件可以用于处理 CSS 预处理器、代码格式化、状态管理库集成等等，让你能够按需定制和配置你的 Vue 项目。

因此，可以将 Vue CLI 视为一个应用程序，用于管理和配置 Vue 项目，并提供了一整套开发工具和特性，使你能够更轻松地开发和维护 Vue 应用程序。



### vue的命令行界面

> 是的，Vue CLI 的命令行界面提供了一系列的命令和选项，用于快速创建和管理 Vue 项目，并帮助你安装所需的依赖项。
>
> 通过 Vue CLI 的命令行界面，你可以执行以下操作：
>
> 1. 创建新的 Vue 项目：使用 `vue create` 命令可以创建一个新的 Vue 项目。在创建过程中，你可以选择使用默认的预设配置或自定义配置，例如选择使用特定的插件、配置包管理工具等。
>
> 2. 添加插件和工具：使用 `vue add` 命令可以添加 Vue CLI 插件和工具，扩展项目的功能。这些插件可以用于集成 CSS 预处理器、添加路由、状态管理库等等。
>
> 3. 启动开发服务器：使用 `vue serve` 命令可以启动一个开发服务器，用于在开发过程中预览和调试你的 Vue 应用程序。
>
> 4. 构建项目：使用 `vue build` 命令可以将 Vue 项目构建为生产环境所需的静态文件，用于部署和发布你的应用程序。
>
> 5. 运行单元测试：使用 `vue test` 命令可以运行项目的单元测试，以确保代码的质量和功能的正确性。
>
> 除了上述命令之外，Vue CLI 还提供了其他一些有用的命令和选项，用于项目的配置、依赖管理和自定义模板等。
>
> 通过这些命令行指令和选项，Vue CLI 提供了一个方便快捷的方式来创建、配置和管理 Vue 项目，并自动处理项目的依赖项安装和构建过程，简化了 Vue 应用程序的开发流程。



## 扩展知识： window命令行无法跨盘访问文件

在某些操作系统中，如Windows系统，每个驱动器被视为独立的存储设备，因此默认情况下无法直接在命令行中跨盘访问。这意味着如果你当前在C盘（例如，命令行提示符显示为`C:\>`），你无法使用`cd`命令直接切换到D盘或执行D盘上的命令。

要在命令行中跨盘访问，你可以尝试以下两种方法：

1. 使用**驱动器标签**（仅适用于Windows）：
   - 在命令行中，输入驱动器标签（例如`D:`）。
   - 这将切换到具有指定标签的驱动器，而不是使用当前工作目录。
   - 例如，**输入`D:`并按下回车键，你将切换到D盘**。

2. 使用绝对路径：
   - 在命令行中，使用绝对路径来执行跨盘操作。
   - 例如，要列出D盘上的文件，可以输入`dir D:\`。

请注意，这些方法仅适用于在命令行中进行临时操作。如果你想在脚本或批处理文件中执行跨盘操作，你需要相应地调整命令或使用其他技术（如使用PowerShell）来实现。

另外，如果你在D盘中进行操作时仍然受到权限限制，可能需要检查你的用户账户是否具有足够的权限来访问和操作D盘上的文件。



> 确实，在命令行中，默认情况下是无法直接跨盘访问的。你提到的通过文件地址栏形式进入命令行，也就是在资源管理器的文件地址栏中输入 "cmd" 命令来打开命令行窗口。
>
> 这种方式可以通过在资源管理器中打开命令行，然后在命令行中执行跨盘操作。你可以尝试以下步骤：
>
> 1. 打开资源管理器（文件资源管理器）。
>
> 2. 在地址栏中输入 "cmd" 并按下回车键。
>
> 3. 这将在资源管理器的当前目录下打开命令行窗口。
>
> 4. 在打开的命令行窗口中，你可以输入 "D:" 命令切换到D盘。
>
> 通过这种方式打开的命令行窗口会自动定位到资源管理器当前所在的路径，因此你可以直接进行跨盘操作。
>
> 请注意，这种方式只适用于通过资源管理器打开的命令行窗口。如果你在其他方式下打开的命令行窗口（如通过开始菜单或快捷方式），则仍然无法直接跨盘访问，需要通过其他方法来实现。



### C盘和D盘对应两个驱动器

>是的，在Windows系统中，通常将不同的物理磁盘或分区分配给不同的驱动器号。例如，C盘和D盘通常对应着两个不同的驱动器。
>
>在命令行中，使用`cd`命令只能在当前驱动器内切换目录，而无法直接跨驱动器切换。要切换到D驱动器，你可以直接输入驱动器号加上冒号（例如，`D:`），然后按下回车键。这将更改命令行的当前工作驱动器为D驱动器，使你可以在D盘上执行操作。
>
>示例：
>```
>C:\> D:
>D:\>
>```
>
>在切换到D驱动器后，你可以使用命令行的其他指令来操作D盘上的文件和目录。请注意，在切换驱动器后，你需要使用该驱动器的相对路径或绝对路径来引用D盘上的文件和目录。例如，`D:\folder\file.txt` 表示D盘上的文件路径。
>
>需要注意的是，跨驱动器操作时，每个驱动器具有自己的当前目录。因此，在C盘切换到D盘后，D盘的当前目录将不受C盘的影响。如果需要在不同驱动器之间切换并保持相同的当前目录，可以使用完整的路径来引用目标文件或目录。



### .vuerc 是全局配置

>是的，`.vuerc` 是一个全局配置文件，用于保存 Vue CLI 的全局配置选项。
>
>在 Windows 系统上，`.vuerc` 文件通常位于用户的主目录下，路径为 `C:\Users\用户名\.vuerc`。该文件保存了全局配置选项，如包管理工具、预设模板等。
>
>通过修改 `.vuerc` 文件中的配置选项，可以自定义全局的 Vue CLI 设置。例如，你可以更改全局的包管理工具，设置默认的预设模板等。
>
>需要注意的是，修改全局配置文件可能对所有 Vue CLI 项目生效，因此在修改之前请确保理解和考虑其影响。此外，修改全局配置需要管理员权限或适当的用户权限。
>
>如果你只想在特定的项目中更改配置，可以在项目的根目录中创建一个名为 `.vuerc` 的文件，并在其中定义项目特定的配置选项。这样，该配置文件将覆盖全局配置，仅对当前项目生效。
>
>在进行任何修改之前，请确保备份相关文件，以防止意外情况发生。



###   "useTaobaoRegistry": true,  "packageManager": "npm"

根据提供的信息，执行了 `vue config packageManager npm` 命令后，输出结果显示了配置文件 `.vuerc` 的解析结果。

解析的结果显示了以下内容：
- `"useTaobaoRegistry": true`：表示使用淘宝镜像源进行包的安装。
- `"packageManager": "npm"`：表示当前项目使用 Npm 作为默认的包管理工具。

这些配置项是 Vue CLI 的全局配置选项，它们会影响到使用 Vue CLI 创建的项目的行为。

通过配置文件 `.vuerc`，可以设置一些全局的选项，例如包管理工具、镜像源、预设模板等。这样，在创建新的 Vue 项目时，Vue CLI 将会使用这些全局配置。

需要注意的是，`.vuerc` 文件是一个 JSON 格式的文件，它保存了 Vue CLI 的全局配置选项。你可以手动编辑该文件来修改全局配置。

当你执行 `vue config packageManager npm` 命令时，Vue CLI 会解析 `.vuerc` 文件，并显示解析后的结果。

这些配置选项可以影响你的项目的行为，例如使用哪个包管理工具、从哪个镜像源下载包等。

请确保在进行任何配置更改之前备份相关文件 ，以防止意外情况发生。同时，了解配置选项的含义和影响对于正确配置项目非常重要。



## Babel 编译器的作用

> Babel 编译器的作用是将使用了较新版本 JavaScript 语言特性的代码转换为向后兼容的代码，以便在不支持这些新特性的环境中运行。以下是 Babel 编译器的几个主要作用：
>
> 1. **语法转换**：Babel 可以将使用了最新 ECMAScript 标准中的语法特性的代码转换为支持更旧 JavaScript 版本的语法。例如，将使用了箭头函数、模板字符串、解构赋值等语法的代码转换为使用 ES5 语法的等效代码。
>
> 2. **转换新特性**：Babel 可以将使用了最新 ECMAScript 标准中的新特性（如 async/await、装饰器、类属性等）的代码转换为可以在旧版本 JavaScript 运行时中执行的代码。这样，开发者可以在现代 JavaScript 特性的基础上编写代码，而不必担心它们是否被目标环境支持。
>
> 3. **平台兼容性**：Babel 可以根据目标环境的配置来选择性地转换特定的语法和新特性。这样，你可以根据你的项目需要选择性地支持不同的浏览器、运行时或平台。
>
> 4. **插件扩展**：Babel 的插件系统使开发者能够根据需要添加自定义转换规则或使用第三方插件来扩展 Babel 的功能。这样，你可以根据项目的需求，通过插件来处理更特定的转换逻辑或支持特定的功能。
>
> 总而言之，Babel 编译器的作用是将使用了最新 JavaScript 特性的代码转换为向后兼容的代码，以便在不同的 JavaScript 运行时环境中执行。它使开发者能够使用最新的语言特性，同时保持代码在各种环境中的兼容性。



## render函数

`render` 函数的作用是返回虚拟 DOM。在 Vue 中，通过调用 `render` 函数来生成应用程序的 DOM 结构。

在 Vue 2 中，`render` 函数使用 `createElement` 参数来创建虚拟 DOM 元素。可以使用 `createElement` 方法来定义和组合虚拟 DOM 元素，并最终返回一个根级别的虚拟 DOM 元素。这个根级别的虚拟 DOM 元素会被 Vue 用于渲染实际的 DOM，并呈现在浏览器中。

在你提供的代码中，箭头函数 `(h) => h(App)` 作为 `render` 函数的实现。这个函数简写的形式实际上是接收一个参数 `h`，它是 `createElement` 方法的别名。在函数体中，直接调用 `h(App)` 创建了一个根级别的虚拟 DOM 元素，并将其作为返回值。这个虚拟 DOM 元素将被用于渲染应用程序的根 DOM 节点。

所以，是的，`render` 函数的作用是返回虚拟 DOM 元素，它定义了应用程序的整体结构和内容。



### render函数返回u虚拟dom

返回虚拟 DOM 的主要用途是为 Vue 的渲染函数提供描述应用程序界面的代码结构。通过使用虚拟 DOM，Vue 可以更高效地跟踪和更新应用程序的视图。

以下是使用虚拟 DOM 的几个好处：

1. 性能优化：Vue 使用虚拟 DOM 来跟踪 DOM 的变化，并通过 diff 算法进行高效地更新。只有真正发生变化的部分会被重新渲染，这样可以减少不必要的 DOM 操作，提高性能。

2. 跨平台：虚拟 DOM 是与平台无关的，可以用于渲染到不同的目标环境，如浏览器、服务器、移动设备等。

3. 组件化开发：虚拟 DOM 允许将界面拆分为独立的组件，每个组件都可以具有自己的虚拟 DOM 结构。这种组件化开发的方式使得代码的可维护性和复用性更高。

4. 状态管理：通过返回虚拟 DOM，Vue 可以更好地跟踪应用程序的状态变化，并在需要时更新界面。这使得状态管理更加简单和可控。

总之，返回虚拟 DOM 可以帮助 Vue 更好地管理和更新应用程序的界面，提高性能和开发效率。



`render` 函数用于返回一个虚拟 DOM 元素，而不是直接在页面上生成 DOM 元素。

在 Vue 中，虚拟 DOM 是通过 `createElement` 方法创建的，它表示一个描述真实 DOM 结构的 JavaScript 对象。`render` 函数接收 `createElement` 方法作为参数，通过调用 `createElement` 方法创建虚拟 DOM 元素，并返回给 Vue，然后 Vue 会将虚拟 DOM 转化为真实 DOM，并将其渲染到页面上。

使用 `render` 函数的好处是可以在运行时动态生成虚拟 DOM，根据组件的状态、属性等进行灵活的渲染。同时，虚拟 DOM 的比较和更新过程也可以更高效地进行。

相比之下，直接在模板中生成 DOM 元素是使用模板语法的方式，它将模板编译为渲染函数，并最终生成虚拟 DOM。模板语法相对简单，更适合静态的 DOM 结构。

无论是使用 `render` 函数还是模板语法，最终都会生成虚拟 DOM，并通过 Vue 的内部机制将其转化为真实 DOM 并进行渲染。



**new Vue({  render: h => h(App), }).$mount('#app') ，这行是直接返回一个dom元素，并挂载到app是吗?**



是的，这行代码的作用是创建一个 Vue 实例，并将其挂载到指定的 DOM 元素上。

首先，通过 `new Vue()` 创建了一个 Vue 实例，传入的配置对象中包含了 `render` 属性，其值是一个函数 `h => h(App)`。这里的 `h` 是 `createElement` 函数的简写形式，用于创建虚拟 DOM 元素。

`h(App)` 表示调用 `createElement` 创建一个虚拟 DOM 元素，该元素对应的是根组件 `App`。这个根组件会作为整个 Vue 应用的顶层组件。

然后，通过调用 `$mount('#app')` 方法将 Vue 实例挂载到指定的 DOM 元素上。`'#app'` 表示挂载到具有 `id` 为 `app` 的 DOM 元素上。

最终，Vue 实例会根据 `render` 函数生成的虚拟 DOM，将其转化为真实 DOM，并将其渲染到挂载的 DOM 元素上，完成组件的渲染和挂载过程。



## return 和 render

这两种方式创建 Vue 实例的方式在功能上是等效的，它们都可以用于创建 Vue 应用并将其挂载到指定的 DOM 元素上。

区别在于配置对象的不同：

- 使用 `render` 函数的方式是 Vue 2.x 版本中的写法，它使用了 Vue 的渲染函数，通过函数的方式来生成虚拟 DOM 元素，并将其渲染到指定的 DOM 元素上。
- 使用配置对象的方式是 Vue 2.x 版本中的常见写法，其中的 `el` 属性指定了要挂载的 DOM 元素的选择器，`data` 属性定义了组件的响应式数据，`methods` 属性定义了组件的方法。

从功能上来说，两种方式都能实现相同的效果。但是使用 `render` 函数的方式更加灵活，可以实现更复杂的组件渲染逻辑，例如动态生成组件、条件渲染等。

所以，如果你需要更灵活的渲染逻辑，或者你习惯使用函数式的写法，可以选择使用 `render` 函数的方式。如果你更习惯使用配置对象的方式，并且应用的渲染逻辑相对简单，那么可以使用配置对象的方式。



### 组件的插入，一种间接代替的路由跳转功能

>
>
>在 Vue 应用中，组件的插入可以实现页面内容的切换，这可以被视为一种间接的路由跳转功能。
>
>通常情况下，使用 Vue Router 是更常见和灵活的方式来实现路由跳转。Vue Router 是 Vue.js 官方提供的路由管理库，它能够帮助你实现单页应用中的路由功能。通过 Vue Router，你可以定义路由规则，并在不同的路由之间进行切换，实现页面的动态更新。
>
>然而，对于简单的应用或者特定的场景，你也可以通过组件的插入来实现类似的效果。在你提供的代码中，通过在 `<template>` 部分插入 `<HelloWorld>` 组件，可以在应用中显示该组件的内容。这种方式可以用于简单的页面切换，但在涉及到更复杂的路由逻辑、传参和状态管理时，使用 Vue Router 是更为推荐的选择。



# 6.15 日总结

环境配置： 需要依照视频教学观看， 由于环境配置失败 ， 浪费了2-3小时

手脚架版本不同， 执行语句不同会导致最终的编译环境不同，导致失败



 Vue CLI 高版本 的创建项目 逐渐抛弃旧版本的初始化，快捷生成，这也是导致环境配置失败的原因，失败指搭建的环境： 跟项目环境不同，目前能力暂时未能解决

>
>
>从 Vue CLI 3.0 版本开始，`vue create` 命令创建项目时不再提供初始化选项。相反，它会引导你通过一系列提示来配置和选择项目的特性。
>
>当你运行 `vue create` 命令时，它会提示你选择一个预设（preset），预设是一组预配置的项目选项，包括了常用的配置和插件。你可以选择默认的预设，也可以选择手动配置项目。
>
>下面是 `vue create` 命令的常见工作流程：
>
>1. 运行 `vue create` 命令，在命令行中选择一个项目名称。
>2. 然后，Vue CLI 会询问你想要使用的预设。你可以选择默认的预设（默认选项），也可以选择手动配置项目。
>3. 如果选择手动配置项目，Vue CLI 会询问你想要的特性，例如使用 Babel、TypeScript、CSS 预处理器、Linter 等。
>4. 根据你的选择，Vue CLI 会为你安装所需的依赖项，并生成项目的初始文件结构。
>
>请注意，Vue CLI 4.5.0 及更高版本引入了“快速原型”（Vue 2）和“快速原型（TypeScript）”（Vue 3）预设，它们提供了一个简化的项目设置，适用于快速原型开发。你可以选择其中一个预设，它会为你创建一个简单的项目结构，并启用 Vue 的开发服务器。
>
>因此，通过使用 `vue create` 命令并按照提示进行配置，你可以创建一个自定义的 Vue 项目。



比如今天开局的生成项目： 生成的包下载工具， 由于版本不同，默认为yarn,vuecc文件中自动配置- 导致创建的项目也为 yarn



##  Vue.js : 构建方式: "Runtime + Compiler" 和 "Runtime-only"

>
>
>"Runtime + Compiler" 和 "Runtime-only" 是 Vue.js 构建方式的两种选择。
>
>- "Runtime + Compiler" 构建方式包含了模板编译器。它能够在运行时编译模板，并将其转换为渲染函数。这种构建方式适用于使用完整的 Vue 模板语法（包括模板中的动态内容和指令）的项目。它提供了更灵活的模板编写方式，但会增加应用的体积。
>
>- "Runtime-only" 构建方式没有模板编译器，只包含运行时的 Vue.js。它假设你使用了预编译的渲染函数或者使用了单文件组件 (SFC)。这种构建方式适用于使用 Vue 单文件组件或者手动编写渲染函数的项目。它能够减小应用的体积，但会限制模板语法的灵活性。
>
>要选择使用哪种构建方式，需要在创建项目或构建项目时进行相应的配置。在 Vue CLI 中，你可以在创建项目时选择 "Default"（默认）配置，它会使用 "Runtime + Compiler" 构建方式。如果你需要使用 "Runtime-only" 构建方式，可以选择手动配置并去掉模板编译器的选项。
>
>需要注意的是，选择哪种构建方式取决于你的项目需求和性能要求。如果你需要更灵活的模板语法并愿意承受一些额外的体积，可以选择 "Runtime + Compiler"。如果你的项目使用了预编译的渲染函数或者单文件组件，并且希望减小应用的体积，可以选择 "Runtime-only"。





### vue.runtime.esm.js:4605 [Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. (found in <Root>)



> 这个警告信息是因为你正在使用 Vue 的 runtime-only 构建，而没有包含模板编译器。在 Vue 2.x 版本中，有两种构建方式可供选择：
>
> 1. Runtime + Compiler 构建：这个构建包含了 Vue 的运行时和模板编译器，可以直接使用 `<template>` 标签编写模板。你可以通过在 `<script>` 标签中导入完整的 Vue 库来使用这个构建方式：
>
>    ```javascript
>    import Vue from 'vue'
>    ```
>
> 2. Runtime-only 构建：这个构建不包含模板编译器，需要使用渲染函数来编写模板。它体积更小，运行时性能更高。在这种构建方式下，你需要在代码中手动编写渲染函数来生成组件的内容。
>
>    ```javascript
>    import Vue from 'vue/dist/vue.runtime.esm.js'
>    ```
>
> 根据你的警告信息，你正在使用的是 runtime-only 构建，但在代码中却使用了模板。要解决这个问题，你可以按照以下方法之一进行修改：
>
> 1. 将 `import Vue from 'vue/dist/vue.runtime.esm.js'` 改为 `import Vue from 'vue'`，使用 Runtime + Compiler 构建。
> 2. 将模板代码转换为渲染函数，以适应 runtime-only 构建。你可以在 Vue 官方文档中查找有关渲染函数的详细信息和示例。
>
> 根据你的需求和项目配置，选择适合的构建方式，并相应地调整代码。



### 报错会导致内容不显示



> 是的，当出现这个警告并且未解决时，可能会导致组件的内容无法正确显示。警告信息表明你正在使用的是 Vue 的 runtime-only 构建，而模板编译器不可用。在 Vue 2.x 中，如果你想使用模板编写组件的内容，需要使用 Runtime + Compiler 构建。
>
> 由于 runtime-only 构建不包含模板编译器，它无法直接解析和渲染 `<template>` 标签中的模板内容。因此，如果你在代码中使用了模板，并且没有正确配置编译器，可能会导致组件的内容不显示。
>
> 要解决这个问题，你可以选择以下其中一种方法：
> 1. 使用 Runtime + Compiler 构建，即将 `import Vue from 'vue/dist/vue.runtime.esm.js'` 改为 `import Vue from 'vue'`。这样，你就可以使用模板来编写组件的内容。
> 2. 将模板代码转换为渲染函数，以适应 runtime-only 构建。你需要手动编写渲染函数来生成组件的内容。在 Vue 官方文档中可以找到有关渲染函数的详细信息和示例。
>
> 确保按照适合你的项目需求和配置的方式来调整代码，以确保组件的内容能够正确显示。
