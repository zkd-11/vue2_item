## 2022百度前端工程师校招

> 作者：@Pheanake 时间：2021/10/11

> 微信：17002500160 欢迎骚扰交流，记得给备注，近期会开始创建公众号敬请期待！

#### 准备情况：

```
收到面试邀请是自己做交互设计实习离职的第一天，有一点措手不及，前端有接近一年左右的时间没有接触。
在面试之前没有任何准备，仅面试前半天复习了一下。
```

#### 简单说一下大致的面试过程以及面试问题：

```
1. 介绍一下你自己
2. 说一说常见的排序算法有哪些，用JavaScript实现一个快速排序（10分钟手写代码）
3. 说一说常见的垂直水平居中方案，若父元素未知宽高，怎么实现子元素垂直水平居中，除了flex有没有其他方案（手写CSS样式）
4. 讲一讲盒模型有哪些？区别是什么？各个浏览器的兼容性如何？怎么解决兼容性问题？
5. 讲一讲什么是跨域？有哪些方案可以解决？讲一讲怎么用src属性来实现跨域？
6. 说一说熟悉的ES6新特性，`module.exports`与node里面的`exports`有什么区别？
7. 说一说熟悉的设计模式？写一下工厂模式（手写代码）
8. 说一说平时怎么学习前端的？
```

#### 总结：

```
面试官非常友好尽可能给提示,选择一些简单的问题提问，问题偏向基础稍微复习一下都能回答出来，自己准备非常不充分，继续背八股文。
给后来者一个建议，种一棵树最好是十年前，其次是现在。
```

​	

## 2 说一说常见的排序算法有哪些，用JavaScript实现一个快速排序（10分钟手写代码）

![img](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015233043168-1867817869.png)

​	

下面是一个使用JavaScript实现的快速排序的示例代码：

```js
// 定义快速排序函数，接受一个数组作为参数
function quickSort(arr) {
  // 如果数组长度小于等于1，直接返回原数组
  if (arr.length <= 1) {
    return arr;
  }

  // 选择数组中间的一项作为基准
  const pivot = arr[Math.floor(arr.length / 2)];
  // 定义一个左侧数组
  const left = [];
  // 定义一个右侧数组
  const right = [];

  // 循环遍历数组，将小于基准的项放入左侧数组，大于等于基准的项放入右侧数组
  for (let i = 0; i < arr.length; i++) {
    // 如果当前项是基准项，则跳过
    if (i === Math.floor(arr.length / 2)) {
      continue;
    }
    // 如果当前项小于基准项，则放入左侧数组
    if (arr[i] < pivot) {
      left.push(arr[i]);
    // 否则，放入右侧数组
    } else {
      right.push(arr[i]);
    }
  }

  // 递归调用quickSort函数，对左侧数组和右侧数组分别进行快速排序，并将结果与基准项合并在一起
  return [...quickSort(left), pivot, ...quickSort(right)];
}

// 测试用例
console.log(quickSort([])); // []
console.log(quickSort([1])); // [1]
console.log(quickSort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])); // [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]
console.log(quickSort([5, 4, 3, 2, 1])); // [1, 2, 3, 4, 5]
```

在这个例子中，我们首先检查数组长度是否小于等于1，如果是，则返回原始数组。否则，我们选择数组的中间项作为“基准”（pivot），并将小于基准的所有项移动到一个数组中，大于等于基准的所有项移动到另一个数组中。最后，我们递归地调用quickSort函数来对左侧和右侧的数组进行排序，并将结果与基准合并在一起。

我们使用了四个测试用例来验证快速排序函数的正确性，这些用例分别是：

- 空数组：这个用例可以测试快速排序函数在处理边界条件时的正确性。
- 只包含一项的数组：这个用例可以测试快速排序函数在处理小数组时的正确性。
- 包含多个项的数组：这个用例可以测试快速排序函数在处理大数组时的正确性。
- 逆序排列的数组：这个用例可以测试快速排序函数在处理具有一定难度的数组时的正确性。

总的来说，快速排序是一种高效的排序算法，可以在大多数情况下很好地工作。但是，当数组非常大时，递归调用quickSort函数可能会导致栈溢出，因此需要采用一些优化策略来避免这种情况。

​	

**讲一下js中的Math.floor()**

`Math.floor()`是JavaScript中的一个内置方法，用于向下取整一个数，返回不大于传入参数的最大整数值。

例如：

```js
Math.floor(1.9); // 1
Math.floor(-1.9); // -2
```

`Math.floor()`方法的参数可以是任何一个数字，可以是整数或者浮点数。当传入参数为正数时，该方法将返回不大于该参数的最大整数值；当传入参数为负数时，`Math.floor()`方法将返回不大于该参数的最大整数值（向下取整）

需要注意的是，使用`Math.floor()`方法时，传入的参数会被自动转换为数字类型。如果传入的参数是一个字符串，会先被转换为数字类型，然后再进行向下取整的操作。如果传入的参数不能被转换为数字类型，则返回`NaN`。

> 上面快速排序中，let声明变量相当于c++的auto，变量类型不固定，所以用Math.floor()向下取整为整型

​	

**讲一下 ...**

> 在 JavaScript 中，`...` 是扩展运算符，也称为剩余运算符。它可以将一个可迭代对象（例如数组、字符串、Map、Set 等）拆分成单独的元素，也可以将多个元素合并成一个数组。`...` 主要有以下用途：
>
> 1. 将数组拆分成单独的元素：
>
> ```js
> const arr = [1, 2, 3];
> console.log(...arr); // 输出 1 2 3
> ```
>
> 2. 将多个元素合并成一个数组：
>
> ```js
> const arr1 = [1, 2, 3];
> const arr2 = [4, 5, 6];
> const newArr = [...arr1, ...arr2];
> console.log(newArr); // 输出 [1, 2, 3, 4, 5, 6]
> ```
>
> 3. 函数参数传递：
>
> ```js
> function fn(a, b, c) {
>   console.log(a, b, c);
> }
> const arr = [1, 2, 3];
> fn(...arr); // 输出 1 2 3
> ```
>
> 4. 拷贝数组：
>
> ```js
> const arr1 = [1, 2, 3];
> const arr2 = [...arr1];
> ```
>
> 在 `quickSort` 函数中，使用 `...` 可以将数组拆分成单独的元素，再使用 `[]` 将这些元素合并成一个新的数组，这样可以方便地进行数组的拼接操作。例如：
>
> ```js
> return [...quickSort(left), pivot, ...quickSort(right)];
> ```
>
> 这行代码的含义是，将 `quickSort(left)` 的结果和 `pivot` 以及 `quickSort(right)` 的结果合并成一个新的数组，并将这个数组作为 `quickSort` 函数的返回值。由于 `quickSort(left)` 和 `quickSort(right)` 都返回一个数组，因此可以使用 `...` 运算符将它们的结果展开成一个元素列表，然后再用 `[]` 包裹起来，最终得到一个包含所有元素的新数组。

​	

**上面快排代码里[...left, pivot]，[]是合并的意思吗？**

> 是的，[]表示一个新数组，其中的元素就是将`left`和`pivot`数组中的所有元素合并起来的结果。`[...left, pivot]`中的`...`符号表示使用展开语法，将`left`数组中的所有元素展开成独立的值，然后再将`pivot`作为一个独立的值添加到这些值的后面，从而得到一个新的数组。例如，如果`left`为`[3, 5]`，`pivot`为`2`，那么`[...left, pivot]`将返回`[3, 5, 2]`。

​	

**上面这句代码不太理解 return [...quickSort(left), pivot, ...quickSort(right)]; 能不能帮我详细讲一下**

> 当递归到最后，如果 left 和 right 都只剩下一个元素或没有元素时，就会返回这两个数组。但是，当递归结束后，每个左部分和右部分都会变成只包含一个元素或空数组的子数组。所以需要使用扩展运算符 `...` 将这些数组拼接在一起，形成一个新的完整的数组，以此来实现归并排序的效果。
>
> 具体地说，使用 `...` 可以将两个数组拼接在一起，例如 `[...left, pivot]` 就是将 `left` 数组和 `pivot` 元素合并成一个新的数组，`[pivot, ...right]` 同理。最终的 `return` 语句就是将左半部分、中间的基准值、右半部分三个数组拼接成一个新的数组。
>
> 相当于：
>
> ```js
> return quickSort(left).concat([pivot], quickSort(right));
> ```
>
> 但是，使用 `...` 的形式更为简洁、易读。

​	

扩展一下，以下是使用C++实现的快速排序算法：

```c++
#include <iostream>
#include <vector>

using namespace std;

void quickSort(vector<int>& arr, int left, int right) {
    if (left >= right) {
        return;
    }
    int pivot = arr[left];
    int i = left, j = right;
    while (i < j) {
        while (i < j && arr[j] >= pivot) {
            j--;
        }
        arr[i] = arr[j];
        while (i < j && arr[i] < pivot) {
            i++;
        }
        arr[j] = arr[i];
    }
    arr[i] = pivot;
    quickSort(arr, left, i - 1);
    quickSort(arr, i + 1, right);
}

int main() {
    vector<int> arr = {9, 5, 7, 3, 1, 6, 8, 2, 4};
    quickSort(arr, 0, arr.size() - 1);
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    return 0;
}
```

**难点与小结**：首先左指针与右指针一定是**右指针先走**，刚开始我也对while循环里的`arr[i] = arr[j];`和`arr[j] = arr[i];`整懵圈，怎么看都不像是交换值，因为没有临时变量temp进行值存储，但其实 `int pivot = arr[left];` 就相当于temp，已经记录左指针第一个数了（同时也是我们的基准数）。之后指针j从右往左扫描数组，找到第一个小于基准值pivot的元素，然后停止扫描。接着，指针i从左往右扫描数组，找到第一个大于等于基准值pivot的元素，然后停止扫描。如果i和j的位置没有交叉，则将它们对应的元素交换位置，直到i和j的位置交叉为止（i==j）

循环这个过程直到i和j的位置交叉，就可以将数组分成两部分，左边部分小于基准值，右边部分大于等于基准值。

​	

## 3 说一说常见的垂直水平居中方案，若父元素未知宽高，怎么实现子元素垂直水平居中，除了flex有没有其他方案（手写CSS样式）

如果父元素未知宽高，实现子元素的垂直水平居中可以采用以下方法：

1. 使用绝对定位和transform

可以将子元素设置为绝对定位，同时将left、top、right、bottom属性设置为0，这样子元素就会覆盖整个父元素。然后使用CSS3的transform属性来将子元素向左上方移动自身宽高的一半，以达到居中的效果。

```css
.parent {
  position: relative;
}

.child {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```

2. 使用绝对定位和负边距

可以将子元素设置为绝对定位，然后将left、top、right、bottom属性都设置为0，并使用负边距来修正子元素的位置。

```css
.parent {
  position: relative;
}

.child {
  position: absolute;
  top: 50%;
  left: 50%;
  margin-top: -50px; /* 垂直方向负半高 */
  margin-left: -50px; /* 水平方向负半宽 */
}
```

3. 使用Flex布局

需要注意的是，如果父元素没有固定的宽高，那么这种方法可能会让子元素溢出父元素的边界。在这种情况下，可以考虑使用相对定位或绝对定位等其他方法来实现垂直水平居中。

```css
.parent {
  display: flex;
  justify-content: center; /* 水平居中 */
  align-items: center; /* 垂直居中 */
}

.child {
  /* 子元素的样式 */
}
```

