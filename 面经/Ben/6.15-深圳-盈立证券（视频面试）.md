> 小结：很想去的一个公司，不过今天运势不好，也有点仓促面试准备的时候，公司要求的岗位职责没看完，没准备好，很可惜很难过的一次

# 6.15-深圳-盈立证券

自我介绍

## 商城项目有部署吗？

​	

## 可以看下项目吗？

​	

## 能说下登录模块是怎么做的吗？

在Vue项目中，登录模块通常涉及以下几个关键步骤：

1. 创建登录表单：在Vue组件中，首先创建一个登录表单，包含用户名和密码的输入字段以及登录按钮。

```vue
<template>
  <div>
    <input type="text" v-model="username" placeholder="用户名">
    <input type="password" v-model="password" placeholder="密码">
    <button @click="login">登录</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      username: '',
      password: ''
    };
  },
  methods: {
    login() {
      // 在这里处理登录逻辑
    }
  }
};
</script>
```

2. 处理登录逻辑：在登录按钮的点击事件处理函数中，进行登录逻辑的处理。通常，这涉及向后端服务器发送登录请求，验证用户输入的用户名和密码是否有效。

你可以使用Axios或其他HTTP库来发送请求，示例代码如下：

```javascript
import axios from 'axios';

// ...

methods: {
  login() {
    axios.post('/api/login', {
      username: this.username,
      password: this.password
    })
    .then(response => {
      // 登录成功处理
    })
    .catch(error => {
      // 登录失败处理
    });
  }
}
```

3. 处理登录成功和失败：根据后端返回的响应，在登录成功和失败的情况下采取相应的操作。例如，可以在登录成功时进行路由跳转，将用户重定向到受保护的页面，或者显示错误消息给用户。

```javascript
methods: {
  login() {
    axios.post('/api/login', {
      username: this.username,
      password: this.password
    })
    .then(response => {
      // 登录成功处理
      if (response.data.success) {
        // 登录成功，进行路由跳转或其他操作
      } else {
        // 登录失败，显示错误消息给用户
      }
    })
    .catch(error => {
      // 请求错误处理
    });
  }
}
```

以上是一个简单的Vue登录模块的示例。实际项目中，还可以进行更多的安全性和用户体验的优化，例如使用令牌进行身份验证、添加表单验证等。

​	

## 登录密码怎么处理？

处理登录密码时，有一些常见的做法和最佳实践可以考虑，以确保密码的安全性。下面是一些处理登录密码的建议：

1. 避免明文存储：绝对不要以明文形式存储用户的密码。明文存储密码存在极高的安全风险，一旦数据库泄露，攻击者可以直接获取用户的密码。相反，应该对密码进行加密处理。

2. 使用哈希函数进行密码加密：在存储密码时，应该使用哈希函数对密码进行加密。哈希函数将密码转换为不可逆的哈希值，这样即使数据库泄露，攻击者也无法还原密码。常用的哈希函数包括bcrypt、scrypt、PBKDF2等，它们都具有加盐和迭代的特性，增加了密码破解的难度。

3. 加盐存储密码：为了增加密码的安全性，可以使用随机生成的盐值对密码进行加密。盐值是一个随机字符串，与密码进行组合后再进行哈希，以增加密码的熵，提高破解密码的难度。

4. 使用HTTPS协议：在用户登录时，确保使用安全的HTTPS协议进行数据传输。HTTPS通过加密传输数据，防止中间人攻击和窃听。

5. 密码策略和复杂性要求：为了增加密码的安全性，可以要求用户设置强密码，例如至少包含一定长度的字符、数字和特殊符号。还可以限制密码的有效期，并要求用户定期更换密码。

6. 防止暴力破解：为了防止暴力破解密码，可以采取措施限制登录尝试次数，例如在一段时间内连续失败多次后锁定账号或增加验证码验证。

7. 定期更新哈希算法：随着计算能力的提升，一些哈希算法可能变得不安全。因此，应定期评估和更新使用的哈希算法，确保使用当前安全的算法。

需要注意的是，以上是一些建议和最佳实践，但并不是完整的安全解决方案。在实际开发中，还应考虑具体的安全需求和业务场景，以及遵循密码存储和处理的最佳实践。同时，了解密码学和安全领域的最新发展也是重要的，以保持对密码安全性的最新认识。

### 明文传输吗？

### 假如要升级系统登录模块，安全性这方面怎么处理呢？

我：post

面试官：post也会被拦截监听到

我：传输前进行加密，密文传输，密码+自定义专属字段然后通过加密技术（如：MD5）进行加密

**GPT：**

> 如果要升级系统的登录模块以避免明文存储密码，并提高安全性，可以考虑以下几个方面的处理：
>
> 1. 密码加密和哈希存储：将用户密码进行加密处理，并将加密后的密码哈希存储到数据库中。使用适当的哈希算法和加盐技术，如bcrypt、scrypt或PBKDF2，以增加密码的安全性。确保在用户注册或更改密码时，对密码进行加密和哈希处理，并将哈希值存储到数据库中。
>
> 2. 引入盐值：为了增加密码的安全性，使用随机生成的盐值对密码进行加密和哈希处理。每个用户的盐值应该是唯一的，并与密码组合后进行加密和哈希处理。盐值的引入可以有效防止彩虹表攻击和碰撞攻击。
>
> 3. 使用单向哈希函数：确保选择安全的单向哈希函数，这些函数在密码哈希处理中是不可逆的。这样即使数据库泄露，攻击者也无法还原密码。
>
> 4. 加强密码策略：要求用户设置强密码，包括足够的长度、字符、数字和特殊符号的要求。可以使用密码策略模块或正则表达式验证密码的复杂性，并在前端和后端进行校验。
>
> 5. 使用安全的传输协议：确保在登录过程中使用安全的传输协议，如HTTPS，以加密用户输入的用户名和密码，防止中间人攻击和窃听。
>
> 6. 限制登录尝试次数：为了防止暴力破解密码，可以实施限制登录尝试次数的策略。在一段时间内连续失败多次后，可以锁定账号或增加验证码验证。
>
> 7. 引入多因素身份验证：考虑引入多因素身份验证（MFA），例如使用手机验证码、指纹识别或硬件令牌等。这样即使密码被泄露，攻击者也需要其他因素来进行验证。
>
> 8. 定期更新密码哈希算法：随着密码学技术的发展，某些哈希算法可能变得不再安全。定期评估和更新使用的密码哈希算法，确保使用当前安全的算法。
>
> 9. 安全审计和日志记录：记录登录尝试、账号锁定、密码重置等活动，并进行安全审计和日志记录。这有助于检测异常登录行为和及时采取措施。
>
> 10. 安全教育和意识培训：提高用户和开发人员的安全意识，进行安全教育和培训，以了解密码

​	

### 那你密钥怎么存的，存在本地吗？

我：存在本地安全性高的

**GPT：**

作为一个语言模型，我不会存储或使用密钥或其他敏感信息。我的设计和实现旨在确保数据的安全性和保密性。

对于实际应用程序中的密钥管理，以下是一些常见的最佳实践：

1. 密钥存储：密钥应该存储在安全的地方，最好是在专门的密钥管理系统（Key Management System，KMS）中。KMS是一种安全的存储和管理密钥的服务，提供密钥的安全存储、访问控制和生命周期管理等功能。

2. 避免明文存储：密钥绝不能以明文形式存储在代码、配置文件或版本控制系统中。这样做会增加密钥泄露的风险。

3. 加密存储：如果需要在应用程序中存储密钥，应该对密钥进行加密处理，以增加安全性。加密存储可以使用对称加密或非对称加密算法，确保只有授权的实体能够解密密钥。

4. 环境变量：一种常见的做法是使用环境变量来存储密钥。环境变量可以在应用程序启动时由操作系统或容器管理平台提供，并且在运行时只有应用程序可以访问。这种方法可以将密钥与代码分离，并提供一定的安全性。

5. 访问控制：确保只有授权的用户或实体能够访问存储密钥的系统或服务。使用适当的访问控制机制，如访问策略、身份验证和授权，限制对密钥的访问权限。

6. 定期轮换：为了增加密钥的安全性，应该定期轮换密钥。定期更换密钥可以减少密钥被泄露或破解的风险。

7. 监控和审计：实施密钥使用的监控和审计机制，及时检测异常活动和潜在的密钥泄露情况。

需要注意的是，密钥管理是一个复杂的问题，并且取决于具体的应用程序和安全要求。因此，建议在实际开发中，咨询安全专家并遵循安全最佳实践来确保密钥的安全存储和使用。

​	

## 有了解过https吗？

我：有，但收费，没用过

### 它是怎么样的加密过程（原理），怎么解决这个安全问题呢？

我：没看过，不了解（昨天外卖耽搁没看了，操）

**讲一下https，并说明它是怎样的加密过程，如何解决这个安全性的问题？**

> HTTPS（Hypertext Transfer Protocol Secure）是一种安全的HTTP协议，通过使用TLS（Transport Layer Security）或SSL（Secure Sockets Layer）协议对传输的数据进行加密和身份验证，以提供更高的安全性。
>
> HTTPS的加密过程可以简单概括为以下步骤：
>
> 1. 客户端发起连接请求：客户端（通常是Web浏览器）向服务器发起连接请求，请求建立HTTPS连接。
>
> 2. 服务器端证书验证：服务器将自己的数字证书发送给客户端。数字证书是由可信任的证书颁发机构（Certificate Authority，CA）签发的，用于验证服务器的身份。客户端会验证证书的有效性、签发机构和是否属于可信的域名。
>
> 3. 协商加密参数：一旦服务器的身份得到验证，客户端和服务器开始协商加密参数，包括加密算法、密钥长度等。他们选择一种双方都支持的加密算法和密钥。
>
> 4. 密钥交换：客户端生成一个随机的对称密钥，使用服务器的公钥进行加密，然后将加密后的密钥发送给服务器。
>
> 5. 数据传输加密：客户端和服务器使用协商好的对称密钥进行数据传输加密。这意味着数据在传输过程中使用该密钥进行加密和解密。
>
> 通过上述过程，HTTPS提供了以下安全性的解决方案：
>
> 1. 数据加密：HTTPS使用对称密钥加密算法对传输的数据进行加密，防止第三方窃听者在传输过程中获取敏感信息。
>
> 2. 身份验证：服务器通过数字证书验证自己的身份。客户端可以验证证书的有效性和服务器的合法性，确保与正确的服务器进行通信。
>
> 3. 数据完整性：HTTPS使用消息认证码（Message Authentication Code，MAC）来验证数据的完整性。这样可以防止数据在传输过程中被篡改或损坏。
>
> 4. 中间人攻击防护：通过数字证书的验证和加密通信，HTTPS可以防止中间人攻击，即攻击者在客户端和服务器之间插入自己并截获、篡改或窃听通信。
>
> 需要注意的是，HTTPS只保证了数据在传输过程中的安全性，但不能解决其他安全问题，如服务器端的漏洞或不安全的应用程序。因此，综合的安全性需要在应用层面综合考虑，包括合理的身份验证、访问控制、数据处理和存储等方面。

​	

## 那HTTP这块呢？

讲了HTTP的发展史（MDN没白看）

​	

## 状态码这一块呢？

### 304呢？

讲了强缓存过期，要用到协商缓存，用户仍能使用缓存资源

### 怎么识别本地有没有缓存？

> 要识别本地是否有缓存并判断是否需要发送条件请求（使用状态码304），用户可以通过以下方式进行检查：
>
> 1. 查看请求和响应的头信息：在开发者工具或网络调试工具中查看请求和响应的头信息。如果响应头中包含缓存相关的字段，可以判断响应是否被缓存。
>
> 2. 检查缓存控制头：响应头中的缓存控制头字段可以提供有关缓存策略和过期时间的信息。常见的缓存控制头字段包括"Cache-Control"和"Expires"。
>
>    - "Cache-Control"字段：可以指定缓存的行为，如"no-cache"（强制要求缓存服务器重新验证缓存的有效性）或"max-age"（指定缓存的有效时间）等。
>    - "Expires"字段：指定响应的过期时间，即缓存的有效期。
>
>    通过检查这些字段的值，可以判断响应是否被缓存以及缓存的过期时间。
>
> 3. 状态码304判断：当客户端发送带有条件的请求（例如带有If-Modified-Since或If-None-Match头字段）时，服务器会根据这些条件判断是否需要发送完整的响应或返回状态码304（Not Modified）。如果收到状态码304，说明本地缓存是有效的，并且客户端可以使用本地缓存。
>
> 需要注意的是，缓存的逻辑是由服务器和客户端共同控制的，服务器通过设置响应头信息来指示客户端如何处理缓存。客户端会根据响应头信息和自身的缓存策略来判断是否使用缓存。
>
> 在开发中，可以使用浏览器的开发者工具或网络调试工具来查看请求和响应的详细信息，以了解缓存情况。此外，还可以通过在代码中添加适当的缓存控制头字段，来控制缓存行为和过期时间，以满足应用程序的需求。

​	

## 登录模块怎么保持登录状态？比如刷新跳转后，仍然保持登录用户的信息

保存在web storage里

讲了cookie可以设置过期时间

**GPT：**

> 在Vue项目中，要保持登录状态并在刷新或跳转后仍然保持登录用户的信息，通常会使用以下方法之一：
>
> 1. 使用服务器端的会话（Session）：当用户成功登录后，服务器会创建一个会话，并将会话ID保存在Cookie中发送给客户端。客户端在每次请求时都会携带该Cookie，服务器通过会话ID验证用户的身份并返回相应的数据。这种方式需要服务器端的支持，通常通过与后端进行交互来实现。
>
> 2. 使用JWT（JSON Web Token）：JWT是一种用于跨域身份验证的开放标准。在登录成功后，服务器会生成一个JWT，包含用户的身份信息和其他相关信息，并将该JWT发送给客户端。客户端在每次请求时将JWT作为请求头部字段发送给服务器。服务器通过验证JWT的签名和有效期来判断用户的身份，并返回相应的数据。这种方式相对于服务器端会话，前后端可以完全分离，但需要保证JWT的安全性。
>
> 3. 使用浏览器本地存储：在用户登录成功后，将用户的登录信息（如用户ID或令牌）存储在浏览器的本地存储中，如LocalStorage或SessionStorage。在刷新或跳转后，可以从本地存储中获取登录信息，以判断用户是否已登录并显示相应的内容。这种方式相对简单，但需要注意保护用户信息的安全性。
>
> 不论选择哪种方式，都需要在适当的时候进行身份验证和权限控制，以确保用户的登录状态和数据的安全性。同时，应避免将敏感信息存储在前端，仅在需要时从后端获取，并使用合适的加密和安全措施来保护用户的隐私。

### 那如果过期了后台怎么知道呢？

我：使用flag标识状态，并传递给后台

**GPT:**

> 当使用会话（Session）或JWT进行身份验证时，后台可以通过以下方式知道用户的登录状态是否已过期：
>
> 1. 会话过期检查：在会话中，通常会在服务器端设置一个过期时间，用于标识会话的有效期。当用户发送请求时，服务器可以检查会话的过期时间与当前时间的比较，如果过期时间已经超过当前时间，则会话被认为是过期的。
>
> 2. JWT的过期时间检查：JWT通常包含一个过期时间（Expires）字段，用于指示JWT的有效期。后台在接收到包含JWT的请求时，可以解析JWT并检查过期时间字段，如果过期时间已经超过当前时间，则认为JWT已过期。
>
> 无论是会话过期检查还是JWT的过期时间检查，后台可以在每次接收到请求时进行验证。如果发现会话或JWT已过期，后台可以返回相应的错误状态码（如401 Unauthorized）或错误信息，提示用户重新登录或刷新页面获取新的会话或JWT。
>
> 需要注意的是，过期时间的设置应根据具体的应用需求和安全性要求来决定。过长的有效期可能增加安全风险，而过短的有效期可能给用户带来频繁重新登录的不便。因此，需要在权衡用户体验和安全性之间进行合理的设置。

​	

## Vue的响应式原理（恶魔）

讲的支支吾吾

**GPT:**

> Vue的响应式原理是其核心特性之一，它通过使用数据劫持结合观察者模式实现了数据的自动更新。以下是Vue响应式原理的基本工作流程：
>
> 1. 数据劫持：Vue通过使用ES5的Object.defineProperty方法来劫持（或监听）数据对象的属性。在Vue实例创建时，会遍历数据对象的属性，为每个属性添加getter和setter函数。
>
> 2. 响应式依赖收集：在Vue模板中，当访问数据对象的属性时，会触发属性的getter函数。在getter函数中，Vue会收集当前的依赖，即正在使用该属性的Watcher对象。这样，Vue就能够建立起属性与Watcher之间的依赖关系。
>
> 3. 数据更新通知：当数据对象的属性发生变化时，会触发属性的setter函数。在setter函数中，Vue会通知所有依赖于该属性的Watcher对象进行更新。
>
> 4. 更新视图：Watcher接收到数据更新的通知后，会触发相应的更新操作，例如重新渲染视图或执行相应的逻辑。
>
> 通过上述步骤，Vue实现了数据的响应式，当数据发生变化时，相关的视图会自动更新。
>
> 值得注意的是，Vue的响应式原理仅对已经存在的属性进行响应式处理。对于新增的属性，需要使用Vue提供的特定方法（如Vue.set或vm.$set）来进行处理，以便进行依赖收集和更新通知。
>
> 此外，Vue还提供了计算属性（computed）和观察者（watcher）等机制来进一步增强响应式能力。计算属性允许根据已有的响应式数据计算出新的属性值，而观察者可以监听数据的变化并执行相应的逻辑。
>
> 总结而言，Vue的响应式原理通过数据劫持和依赖收集来实现数据与视图之间的自动更新，使开发者能够更便捷地构建响应式的应用程序。

### 怎么收集依赖的？（给自己挖坑）

> 注意：不要以为其他小公司没面试到Vue的核心原理，就可以放弃准备这一部分的知识点，今天就是吃之前没准备响应式种的恶果，希望以后能摆正一下态度
>
> **GPT:**
>
> 在Vue的响应式系统中，收集依赖是通过Watcher对象和Dep（依赖）对象之间的交互实现的。下面是Vue中依赖收集的基本流程：
>
> 1. Watcher对象的创建：在Vue中，每个表达式或计算属性都会对应一个Watcher对象。Watcher对象负责收集依赖并在数据变化时触发更新。
>
> 2. 依赖收集阶段：在组件的渲染过程中，当遇到模板中使用的响应式数据时，会触发Getter函数。Getter函数会执行以下操作：
>
>    a. 创建Dep对象：Dep（依赖）对象用于管理依赖关系，每个响应式数据属性都会对应一个Dep对象。
>
>    b. 将当前Watcher对象添加到Dep对象的依赖列表中：Watcher对象会通过全局变量或栈来记录当前正在求值的Watcher对象。Getter函数在执行过程中，将当前Watcher对象添加到Dep对象的依赖列表中，建立起Watcher对象与Dep对象之间的关联。
>
>    c. 如果当前属性的值是对象或数组，会继续对该对象或数组进行递归依赖收集：这样可以保证深层嵌套的属性也能正确地建立依赖关系。
>
> 3. 依赖更新阶段：当响应式数据发生变化时，Setter函数会被触发。Setter函数会执行以下操作：
>
>    a. 更新数据的值。
>
>    b. 通知Dep对象中的所有Watcher对象进行更新：Setter函数会通知与当前属性关联的Dep对象，然后Dep对象会遍历它的依赖列表，调用每个Watcher对象的update方法。
>
>    c. Watcher对象的update方法触发重新求值：在update方法中，Watcher对象会重新求值，调用相关表达式或计算属性的Getter函数，重新收集最新的依赖。
>
>    d. 如果新的依赖和之前的依赖不一致，则会触发相应的更新操作：这样可以确保只更新发生了变化的部分，提高性能。
>
> 通过上述步骤，Vue实现了依赖的收集和更新机制，确保当响应式数据发生变化时，能够及时更新相关的视图或执行相应的逻辑。这种依赖收集的方式能够自动追踪数据之间的依赖关系，使开发者无需手动处理依赖关系，简化了开发过程。

​	

## Vue的生命周期是怎么执行？

> Vue 的生命周期可以分为创建阶段（Creation）、更新阶段（Update）和销毁阶段（Destruction）三个大的阶段，每个阶段都有相应的生命周期钩子函数。
>
> 1. 创建阶段（Creation）：
>    - beforeCreate：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。
>    - created：在实例创建完成后被立即调用。在这个阶段，可以进行数据的初始化、异步请求、事件监听等操作。
>
> 2. 更新阶段（Update）：
>    - beforeMount：在挂载之前被调用，相关的模板编译和渲染函数生成已完成，但尚未挂载到 DOM 上。
>    - mounted：在实例挂载到 DOM 后被调用。在这个阶段，可以进行 DOM 操作、依赖其他库的初始化、定时器的开启等操作。
>    - beforeUpdate：在更新之前被调用，即数据更新导致重新渲染之前。
>    - updated：在更新完成后被调用。在这个阶段，DOM 已经完成重新渲染，可以进行操作的检查和更新。
>
> 3. 销毁阶段（Destruction）：
>    - beforeDestroy：在实例销毁之前被调用。在这个阶段，实例仍然完全可用，可以进行一些清理工作、解绑事件监听等操作。
>    - destroyed：在实例销毁后被调用。在这个阶段，Vue 实例的所有指令和数据绑定都被解绑，组件也被销毁，可以进行最终的清理工作。
>
> 这些生命周期钩子函数可以通过在 Vue 组件中定义对应的方法来使用，例如：
>
> ```javascript
> new Vue({
>   beforeCreate() {
>     // 在实例创建之前执行的逻辑
>   },
>   created() {
>     // 在实例创建完成后执行的逻辑
>   },
>   beforeMount() {
>     // 在挂载之前执行的逻辑
>   },
>   mounted() {
>     // 在挂载完成后执行的逻辑
>   },
>   beforeUpdate() {
>     // 在更新之前执行的逻辑
>   },
>   updated() {
>     // 在更新完成后执行的逻辑
>   },
>   beforeDestroy() {
>     // 在实例销毁之前执行的逻辑
>   },
>   destroyed() {
>     // 在实例销毁后执行的逻辑
>   }
> });
> ```
>
> 这些生命周期钩子函数允许我们在不同阶段执行相应的操作，例如数据的初始化、异步请求、DOM 操作、事件监听、资源的释放等，从而能够更好地控制组件的生命周期。

​	

## v-if和v-show的区别

### 那这两个会触发哪些生命周期吗？

**GPT:**

在Vue中，`v-if` 和 `v-show` 是两个常用的条件渲染指令，它们在显示和隐藏元素方面有所不同，并且在触发的生命周期钩子方面也有一些区别。

1. `v-if`：
   - 触发的生命周期钩子：当使用 `v-if` 指令条件切换时，会触发被条件渲染的组件的完整生命周期，包括 `beforeCreate`、`created`、`beforeMount`、`mounted`、`beforeUpdate` 和 `updated`。这是因为 `v-if` 是根据条件动态地创建或销毁组件。
   - 注意事项：由于 `v-if` 在条件为 `false` 时销毁组件，因此当条件再次变为 `true` 时，组件会重新创建和挂载。这可能会导致组件的状态重置，因此需要谨慎处理。

2. `v-show`：
   - 触发的生命周期钩子：当使用 `v-show` 指令条件切换时，只会触发组件的 `beforeUpdate` 和 `updated` 生命周期钩子。这是因为 `v-show` 仅仅是通过 CSS 的 `display` 属性控制元素的显示和隐藏，而不会销毁和重新创建组件。
   - 注意事项：由于 `v-show` 只是通过 CSS 控制元素的显示和隐藏，并不涉及组件的销毁和重建，因此在切换时，组件的状态会被保留，不会重置。

需要注意的是，无论是 `v-if` 还是 `v-show`，在首次渲染时都会触发组件的完整生命周期。只有在条件切换时，它们会有所区别。因此，在选择使用 `v-if` 还是 `v-show` 时，除了条件显示与隐藏的需求外，还需考虑对组件生命周期的影响和状态的处理。

### 为什么模板template里写v-if/v-show指令是可以用其功能呢？怎么识别指令这个过程呢？

> 在Vue中，模板（template）中的指令（directives）可以通过Vue的编译器进行解析和识别，从而实现相应的功能。
>
> Vue的编译器在编译过程中会遍历模板，并根据特定的语法规则来解析和识别指令。具体的过程如下：
>
> 1. 解析模板：Vue的编译器会将模板解析为抽象语法树（Abstract Syntax Tree，AST）。AST是一个用于表示代码结构的树形数据结构，它把模板的结构和内容转化为一种易于操作和分析的形式。
>
> 2. 识别指令：在解析模板的过程中，编译器会检查模板中的每个元素，并判断是否存在指令。指令通常以 `v-` 开头，例如 `v-if` 和 `v-show`。
>
> 3. 提取指令的参数和表达式：一旦编译器识别到指令，它会进一步提取指令的参数和表达式。指令的参数用于指定指令的具体功能，而表达式则用于计算指令的值。
>
> 4. 将指令转换为相应的代码逻辑：根据指令的功能和表达式，编译器会将指令转换为相应的代码逻辑。例如，对于 `v-if` 指令，编译器会生成与条件判断相关的代码；对于 `v-show` 指令，编译器会生成与 CSS 显示和隐藏相关的代码。
>
> 5. 生成渲染函数：最后，编译器会将转换后的代码逻辑生成一个渲染函数，该渲染函数用于根据数据和状态生成实际的虚拟DOM树，进而更新视图。
>
> 通过以上的过程，Vue的编译器能够将模板中的指令解析为相应的代码逻辑，并在组件的渲染过程中应用指令的功能。这样，当组件被实例化并渲染时，指令所指定的功能就会生效，例如根据条件显示和隐藏元素（`v-if` 和 `v-show`）等。

​	

## 用过slot插槽吗？

​	

## 作用域链介绍一下（这是哪来的坑？？）

讲了一下闭包

### 用闭包会有什么问题呢？

我：内存泄漏

**GPT:**

> 使用闭包有几个潜在的问题需要注意：
>
> 1. 内存泄漏：闭包会导致函数中的变量一直保持在内存中，即使函数已经执行完毕。如果闭包中引用了大量的对象或数据，而且没有及时释放闭包，可能会导致内存泄漏问题，造成内存占用过高。
>
> 2. 变量共享与修改：闭包中的函数可以访问外部函数的变量，甚至可以修改这些变量的值。这在某些情况下可能会导致意外的结果，特别是在多个闭包中共享同一个变量时。如果不小心修改了共享的变量，可能会引发难以追踪和调试的错误。
>
> 3. 作用域链的影响：闭包会延长变量的生命周期，并且会形成一个作用域链。在闭包中引用的变量，即使在外部函数已经执行完毕后，仍然可以访问和使用。这可能导致一些意外的结果，尤其是当变量的值发生变化时，可能会影响到闭包中的逻辑。
>
> 4. 性能问题：由于闭包需要维护作用域链和引用的变量，因此会消耗更多的内存和计算资源。在大规模或频繁使用闭包的情况下，可能会对性能产生一定的影响。
>
> 为了避免潜在的问题，使用闭包时可以注意以下几点：
>
> - 明确闭包的使用场景，确保真正需要使用闭包时再使用，避免滥用。
> - 注意变量的作用域和生命周期，避免不必要的闭包引用。
> - 及时释放不再需要的闭包，防止内存泄漏。
> - 对共享变量进行合理的管理和控制，避免出现意外的修改。
>
> 综上所述，闭包是一种强大的功能，但也需要谨慎使用，注意处理潜在的问题，以保证代码的可靠性和性能。

### 怎么解决内存泄露？

**GPT:**

> 要解决因闭包带来的内存泄漏问题，可以采取以下几种方式：
>
> 1. 及时释放闭包：在不需要使用闭包时，确保及时解除对闭包的引用。这可以通过将闭包赋值为 `null` 或者将其绑定的事件移除来实现。这样可以确保闭包中的变量可以被垃圾回收机制回收，释放内存。
>
> 2. 减少闭包引用的外部变量：在闭包中尽量避免引用大量的外部变量，或者仅引用必要的变量。当外部变量不再需要被闭包使用时，可以手动解除闭包对这些变量的引用，以便垃圾回收机制可以回收相应的内存。
>
> 3. 使用立即执行函数：将闭包代码包裹在立即执行函数（Immediately Invoked Function Expression，IIFE）中。这样，在立即执行函数执行完毕后，闭包中的变量将不再被引用，从而使得相关内存可以被回收。
>
> 4. 使用 WeakMap 或 WeakSet：如果闭包中引用的外部变量是对象或 DOM 元素等，可以考虑使用 WeakMap 或 WeakSet 来存储这些引用。WeakMap 和 WeakSet 是弱引用的集合，当对象没有其他引用时，垃圾回收机制会自动回收相应的内存，从而解决内存泄漏问题。
>
> 5. 使用工具和性能分析工具：可以使用一些内存分析工具来检测和识别潜在的内存泄漏问题。例如，浏览器的开发者工具中的内存分析器可以帮助定位内存泄漏的源头，从而采取相应的解决措施。
>
> 需要根据具体情况和应用场景选择合适的解决方案。同时，对于复杂的应用程序，应进行细致的代码设计和内存管理，以确保闭包不会导致内存泄漏问题。

​	

## git有用过吗？

回答不错

​	

**css**

## 怎么实现一个移动端页面，首尾固定，中间可滚动条滚动呢？

用绝对定位定位首尾

**GPT:**

> 要实现一个移动端页面，使首尾固定，中间内容可滚动，可以采用以下步骤：
>
> 1. HTML 结构：使用一个容器包裹首尾和中间内容，例如：
>
> ```html
> <div class="container">
>   <header>固定头部</header>
>   <main>可滚动内容</main>
>   <footer>固定底部</footer>
> </div>
> ```
>
> 2. CSS 样式：设置容器的高度，并使用 CSS 的 `position` 和 `overflow` 属性来实现固定和滚动效果。例如：
>
> ```css
> .container {
>   height: 100vh; /* 设置容器高度为视口的高度 */
>   overflow: auto; /* 设置容器内容溢出时显示滚动条 */
>   position: relative; /* 设置容器的定位为相对定位，以便设置固定头部和底部的位置 */
> }
> 
> header {
>   position: fixed; /* 固定头部的位置 */
>   top: 0;
>   left: 0;
>   width: 100%;
>   background-color: #f1f1f1;
> }
> 
> footer {
>   position: fixed; /* 固定底部的位置 */
>   bottom: 0;
>   left: 0;
>   width: 100%;
>   background-color: #f1f1f1;
> }
> 
> main {
>   padding-top: 60px; /* 为了避免内容被固定头部遮挡，设置一个与头部高度相等的上边距 */
>   padding-bottom: 60px; /* 为了避免内容被固定底部遮挡，设置一个与底部高度相等的下边距 */
> }
> ```
>
> 通过设置容器的高度、固定头部和底部的位置以及设置内容区域的上下边距，可以实现首尾固定，中间内容可滚动的效果。
>
> 需要注意的是，移动端页面可能涉及到更多的样式和适配方面的考虑，例如移动设备的屏幕尺寸、响应式设计、滚动条样式等，可以根据具体需求进行调整和优化。

### 还有其他方式呢？

我：设置float，然后主轴方向设置成垂直方向的

**GPT:**

> 除了使用 CSS 的固定定位和溢出属性来实现固定首尾、滚动中间内容的方法，还可以考虑使用 CSS Flexbox 或 CSS Grid 来实现相同的效果。
>
> 1. 使用 Flexbox：
>
> ```html
> <div class="container">
>   <header>固定头部</header>
>   <main>可滚动内容</main>
>   <footer>固定底部</footer>
> </div>
> ```
>
> ```css
> .container {
>   display: flex;
>   flex-direction: column;
>   height: 100vh;
> }
> 
> main {
>   flex: 1;
>   overflow: auto;
> }
> ```
>
> 使用 Flexbox 的布局方式，将容器设置为 `display: flex`，并使用 `flex-direction: column` 将子元素垂直排列。通过将 `main` 元素的 `flex` 属性设置为 1，使其占据剩余的空间，并设置 `overflow: auto` 来实现内容的滚动。
>
> 2. 使用 CSS Grid：
>
> ```html
> <div class="container">
>   <header>固定头部</header>
>   <main>可滚动内容</main>
>   <footer>固定底部</footer>
> </div>
> ```
>
> ```css
> .container {
>   display: grid;
>   grid-template-rows: auto 1fr auto;
>   height: 100vh;
> }
> 
> main {
>   overflow: auto;
> }
> ```
>
> 使用 CSS Grid 的布局方式，通过设置容器的行模板（`grid-template-rows`）来控制各个部分的高度比例。将 `main` 元素设置为 `overflow: auto` 可实现内容的滚动。
>
> 这些方法都能实现移动端页面的首尾固定，中间内容滚动的效果，选择适合自己项目需求和样式布局的方法即可。

​	

## 项目里的图片懒加载怎么做的？

讲了一下原生实现，原理

### 怎么判断到图片可视区域？

补充：后面用了插件市场的lazyload懒加载插件去实现

​	

## ES6的let和const有什么区别吗？

​	

## 数组的操作方法平时有用过哪些吗？

写过技术文章或博客

​	

## 博客自己搭的吗？用的什么搭的？搭在哪里

Hexo，github pages，买了域名，并讲了下情况

​	

## 有贡献过什么开源项目吗？

MDN，提交过pr，语法错误，看http协议的时候

​	

## 平常遇到问题怎么解决？

看问题类型，样式问题先自己浏览器调试或找找小伙伴

去技术社区找，这里不一一列举了

但现在更多是先问gpt

​	

### 怎么搜索你遇到的问题呢？

搜终端给的提示error错误和问题现象的关键字

​	

## 反问

面试官：证券类的web端开发，后台管理系统和app内嵌页面和pc客户端的开发，H5和后台管理系统这些部分比较多，技术栈主要是vue2/3，小程序在维护，少部分用react，pc客户端：electron，也是基于vue去做的

​	

建议：多练多实践，总结复盘思考，不是在你的知识能力范围的你又要去怎么解决？

这个公司不用怎么加班

9点到6点半

​	

> 面试结果大概一周内反馈，hr会沟通的