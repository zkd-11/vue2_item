# 5月26日 杭州 微拍堂

- [x] 1 简历里写项目上线了是吗？

> 没有部署上线，只是将项目源码放到github仓库里，没有买个服务器去部署上线它
>
> 下次回答：有部署过，但服务器过期了

- [x] 2 尝试过打包吗？ （webpack）

> 有，Webpack是一个现代化的静态模块打包工具，广泛用于构建前端应用程序。它将前端项目中的各种资源，如JavaScript、CSS、图像等，视为模块，并通过依赖关系进行静态分析和打包。

webpack的打包原理看过吗？

简单说一下webpack。

webpack打包流程是怎么样的？

webpack打包优化点在哪里？

- [x] 3 css优先级有了解吗？

- [x] 4 http1.0/1.1/2.0的区别知道吗？

> [HTTP 的发展 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP)
>
> ## 讲一下http1.0/1.1/2.0，并说说他们的区别
>
> HTTP（Hypertext Transfer Protocol）是一种用于在客户端和服务器之间传输数据的协议。下面我将介绍HTTP的三个版本：HTTP 1.0、HTTP 1.1和HTTP 2.0，并简要说明它们之间的主要区别。
>
> 1. HTTP 1.0:
>    - HTTP 1.0是最早的版本，它采用**简单的请求-响应模型**。
>    - 每次请求都需要建立一个新的连接，并在完成后关闭连接，导致了较高的延迟。
>    - 不支持持久连接，每个请求都需要重新建立连接。
>    - 不支持请求头的复用，每个请求都需要携带完整的请求头信息。
>    - 不支持管道化（pipelining），即在一个连接上同时发送多个请求。
> 2. HTTP 1.1:
>    - HTTP 1.1是对HTTP 1.0的改进，引入了一些新特性。
>    - 支持**持久连接**，多个请求可以共享同一个连接，减少了连接建立的开销。
>    - 引入了**请求头的复用**，同一个连接上的多个请求可以共享相同的请求头信息，减少了冗余数据的传输。
>    - 引入了**管道化**，允许在一个连接上同时发送多个请求，提高了性能。
>    - 引入了**Host头字段**，使得一个服务器可以承载多个域名。
> 3. HTTP 2.0:
>    - HTTP 2.0是对HTTP 1.x的重大升级，采用了新的二进制协议格式。
>    - **使用二进制协议代替了文本协议**，提高了解析效率。
>    - **引入了多路复用**，允许在一个连接上同时发送多个请求和响应，解决了HTTP 1.x中的队头阻塞问题，提高了并发性能。
>    - **支持头部压缩**，减少了数据传输量。
>    - **引入了服务器推送**（server push），服务器可以主动向客户端推送资源，提高了性能和效率。
>
> 综上所述，HTTP 1.0、HTTP 1.1和HTTP 2.0在连接管理、性能优化和功能扩展等方面有着显著的区别。HTTP 1.1在持久连接、请求头复用和管道化等方面进行了改进，而HTTP 2.0引入了二进制协议、多路复用和服务器推送等先进特性，进一步提升了性能和效率。
>
> ## http3已经广泛使用了吗？现在普遍用http协议是版本几的
>
> 截止到我知识截止日期为止（2021年9月），HTTP/3仍处于实验和采用阶段，并未广泛应用。尽管HTTP/3在一些实验性环境和早期采用中已经得到了一些部署和测试，但它的广泛应用和支持仍在逐步推进中。
>
> 目前，HTTP/1.1仍然是最广泛使用的HTTP协议版本。绝大多数的网络服务和网站都使用HTTP/1.1作为默认协议版本。同时，HTTP/2也已经得到了广泛的支持和应用，许多现代的浏览器和服务器都支持HTTP/2，并且许多网站已经开始采用HTTP/2来提供更好的性能和效率。
>
> 然而，HTTP/3作为下一代HTTP协议的标准，正逐渐被开发和推进，以提供更快的连接建立和数据传输速度。随着QUIC协议的发展和HTTP/3的成熟，预计HTTP/3将逐渐被更多的网站和服务采用。
>
> 由于我无法获得关于当前时间（2023年5月）之后的最新信息，建议查阅最新的技术资料和相关的网络资讯，以了解HTTP/3的最新发展和广泛应用情况。
>
> 截止到我知识截止日期为止（2021年9月），HTTP/3是最新的HTTP协议版本。HTTP/3是基于QUIC（Quick UDP Internet Connections）协议的一种传输协议，它旨在提供更快的连接建立和数据传输速度。
>
> HTTP/3相较于之前的HTTP版本有以下主要变化：
>
> - **使用基于UDP的传输协议QUIC**，而不是基于TCP的传输协议。这可以减少连接建立的延迟，并通过使用多路复用和快速的连接迁移来提供更好的性能和可靠性。
> - **引入了传输层加密（Transport Layer Security，TLS）的必要性**，确保数据在传输过程中的安全性和隐私性。
> - **采用了新的帧格式和流控制机制**，提供更高效的数据传输和管理。

- [x] 5 闭包了解吗？

- [x] 6 项目当中有用到闭包吗？（讲闭包使用场景）

> 定时器、异步处理、封装私有变量

- [x] 7 简历里提到的前端优化技术：资源压缩与合并、图片优化这些详细说一下

- [x] 8 非图片的其他优化有尝试过吗？

> 除了图片优化外，前端还有许多其他优化方法可以改善网页性能和用户体验。以下是一些常见的前端优化技巧：
>
> 1. 文件压缩和合并：通过压缩和合并CSS和JavaScript文件，可以减少文件的大小和数量，从而加快页面加载速度。工具如UglifyJS和CSSNano可以帮助你进行文件压缩和合并操作。
> 2. 延迟加载（Lazy loading）：对于页面中的大型资源（如图片或视频），可以使用延迟加载技术。只有当用户滚动到可见区域时，再加载这些资源，而不是一次性全部加载。这可以减少初始页面加载时间。
> 3. **使用缓存**：通过设置适当的缓存头（Cache-Control、Expires），可以让浏览器缓存静态资源，减少重复的网络请求。这样，当用户再次访问页面时，浏览器可以直接从缓存中获取资源，提高页面加载速度。
> 4. **DNS预解析**：在HTML中使用`<link rel="dns-prefetch">`标签或设置CSS样式中的`dns-prefetch`属性，可以提前解析域名，加速后续的网络请求。
> 5. **使用CDN**（Content Delivery Network）：将静态资源（如图片、CSS和JavaScript文件）托管在全球分布的CDN服务器上，可以使用户从距离较近的服务器获取资源，提高加载速度。
> 6. **响应式设计和移动优化**：使用响应式设计来确保网站能够适应不同屏幕大小和设备类型，同时优化移动端的用户体验。使用媒体查询、弹性布局和移动优化的CSS样式，以及针对移动设备的高效JavaScript代码，可以提升在移动端的性能和用户满意度。
> 7. 减少HTTP请求：减少页面中的资源请求可以加快页面加载速度。可以通过合并CSS和JavaScript文件、使用CSS Sprites来减少图像请求，以及通过使用字体图标替代图像图标来减少额外的图像请求。
> 8. JavaScript性能优化：编写高效的JavaScript代码，避免频繁的DOM操作和重复计算，使用事件委托和异步加载来提高性能。
> 9. **使用浏览器缓存和本地存储**：合理利用浏览器提供的缓存和本地存储机制，例如使用LocalStorage或SessionStorage来存储临时数据，避免重复的网络请求。
>
> 以上只是一些常见的前端优化技巧，实际上还有许多其他优化方法，具体取决于项目的需求和情况。在进行优化时，可以使用工具如性能分析器和浏览器开发者工具

- [x] 9 localstorage、sessionstorage和cookie的区别

> LocalStorage、SessionStorage和Cookie是在Web开发中用于在浏览器端存储数据的三种机制，它们有以下区别：
>
> 1. 存储容量：
>    - LocalStorage：提供了较大的存储容量，通常为5MB或更大。
>    - SessionStorage：提供了较小的存储容量，通常为5MB或更小。
>    - Cookie：存储容量较小，每个Cookie的大小通常限制在4KB左右，且总共的Cookie数也有限制。
> 2. 生命周期：
>    - LocalStorage：数据存储**在用户的浏览器中**，除非主动清除或通过编程删除，否则数据会一直保留。
>    - SessionStorage：数据存储在用户会话期间，一旦用户关闭了浏览器窗口或标签页，数据就会被删除。
>    - Cookie：可以设置Cookie的过期时间，**可以是会话级别的（浏览器关闭后删除）或具体的过期日期**。
> 3. 数据交互：
>    - LocalStorage和SessionStorage：数据存储在浏览器中，只有在同一域名下的页面之间共享。不同的标签页或窗口可以访问相同的LocalStorage和SessionStorage数据。
>    - Cookie：Cookie在每个HTTP请求中通过请求头传递给服务器，服务器可以读取和修改Cookie的值。**Cookie可以跨域名传递**，但有一些限制和安全性考虑。
> 4. 安全性：
>    - LocalStorage和SessionStorage：数据存储在用户的浏览器中，**相对来说比Cookie更安全**，不会在每个HTTP请求中自动发送给服务器。
>    - Cookie：**Cookie存储在浏览器和服务器之间**，需要设置合适的标志位来保护Cookie的安全性。
> 5. 访问方式：
>    - LocalStorage和SessionStorage：通过JavaScript中的`localStorage`和`sessionStorage`对象进行访问。
>    - Cookie：通过JavaScript中的`document.cookie`进行访问。
>
> 总体而言，LocalStorage和SessionStorage提供了更大的存储容量和更长的数据保存时间，适用于在浏览器端保存较大量的数据。Cookie则主要用于在浏览器和服务器之间传递少量的信息。根据具体需求，可以选择适合的存储机制。
>
> ## 讲一下JSON.parse()
>
> `JSON.parse()` 是 JavaScript 中的一个内置函数，用于将 JSON 字符串解析为对应的 JavaScript 对象或值。
>
> 当从服务器端获取到 JSON 格式的数据时，它通常是以字符串的形式传输的。为了在 JavaScript 中使用这些数据，我们需要将字符串解析为原生的 JavaScript 对象或值。这时可以使用 `JSON.parse()` 来完成解析的过程。
>
> `JSON.parse()` 接受一个 JSON 字符串作为参数，并返回对应的 JavaScript 对象或值。解析过程中，它会检查字符串的语法是否符合 JSON 格式，并将其转换为对应的 JavaScript 数据类型。
>
> 例如，假设有以下 JSON 字符串：
>
> ```js
> const jsonString = '{"name": "John", "age": 30, "city": "New York"}';
> ```
>
> 我们可以使用 `JSON.parse()` 将其解析为 JavaScript 对象：
>
> ```js
> const data = JSON.parse(jsonString);
> console.log(data);
> ```
>
> 输出结果为：
>
> ```js
> {
>   name: "John",
>   age: 30,
>   city: "New York"
> }
> ```
>
> 在解析过程中，`JSON.parse()` 会自动将 JSON 字符串中的值转换为对应的 JavaScript 数据类型，如字符串、数字、布尔值等。它还可以解析嵌套的对象和数组。
>
> 需要注意的是，如果传递给 `JSON.parse()` 的字符串不符合 JSON 格式，或包含了不支持的数据类型或语法错误，将会抛出一个 `SyntaxError` 异常。
>
> 总而言之，`JSON.parse()` 是一个用于将 JSON 字符串解析为 JavaScript 对象或值的函数，使得我们可以在 JavaScript 中方便地处理和操作 JSON 数据。
>
> ## 讲一下jsonval[""]
>
> `jsonval[""]` 是 JavaScript 中使用方括号操作符（`[]`）访问 JSON 对象属性的一种形式。
>
> 在 JavaScript 中，JSON 对象是一种常见的数据格式，用于表示结构化的数据。JSON 对象由键值对组成，其中键是字符串，值可以是任意有效的 JSON 数据类型，如字符串、数字、布尔值、对象、数组等。
>
> 要访问 JSON 对象的属性，可以使用两种方式：点操作符（`.`）和方括号操作符（`[]`）。
>
> 例如，假设有以下 JSON 对象：
>
> ```javascript
> const jsonval = {
>   "name": "John",
>   "age": 30,
>   "city": "New York"
> };
> ```
>
> 使用点操作符，可以这样访问属性：
>
> ```javascript
> console.log(jsonval.name); // 输出："John"
> console.log(jsonval.age); // 输出：30
> console.log(jsonval.city); // 输出："New York"
> ```
>
> 使用方括号操作符，可以通过属性名的字符串形式来访问属性。当属性名是一个合法的标识符时，可以直接将属性名放在方括号中：
>
> ```javascript
> console.log(jsonval["name"]); // 输出："John"
> console.log(jsonval["age"]); // 输出：30
> console.log(jsonval["city"]); // 输出："New York"
> ```
>
> 在方括号中，你可以使用任何字符串作为属性名，包括空字符串。如果你使用 `jsonval[""]` 访问属性，它会返回 JSON 对象中空字符串对应的属性值（如果有的话）。
>
> 例如，如果 JSON 对象中存在空字符串属性：
>
> ```javascript
> const jsonval = {
>   "": "Empty string value",
>   "name": "John",
>   "age": 30,
>   "city": "New York"
> };
> 
> console.log(jsonval[""]); // 输出："Empty string value"
> ```
>
> 需要注意的是，点操作符和方括号操作符在大多数情况下是可以互换使用的，但方括号操作符具有更大的灵活性，可以接受动态生成的属性名。因此，当属性名是一个变量或包含特殊字符时，需要使用方括号操作符来访问属性。
>
> 总结起来，`jsonval[""]` 表示访问 JSON 对象中空字符串对应的属性值，方括号操作符可以用于访问 JSON 对象的属性，并且在某些情况下更为灵活。
>
> ## 讲一下unescape()
>
> `unescape()` 是 JavaScript 的一个全局函数，用于将经过编码的字符串解码为原始字符串。
>
> 在 JavaScript 中，有一些特殊字符或非 ASCII 字符可能需要进行编码，以便在 URL、URI 或其他上下文中安全传输或存储。这些编码后的字符串可以使用 `unescape()` 函数进行解码，恢复为原始的字符串。
>
> 例如，如果有以下编码后的字符串：
>
> ```js
> const encodedString = "%E4%BD%A0%E5%A5%BD%2C%20%E4%B8%96%E7%95%8C%EF%BC%81";
> ```
>
> 可以使用 `unescape()` 函数将其解码为原始字符串：
>
> ```js
> const decodedString = unescape(encodedString);
> console.log(decodedString);
> ```
>
> 输出结果为：
>
> ```
> 你好, 世界！
> ```
>
> `unescape()` 函数会解码被 `%` 符号编码的字符，还原为对应的字符。它也可以解码其他一些特殊字符的编码，例如空格（`%20`）、斜杠（`%2F`）、等号（`%3D`）等。
>
> 需要注意的是，`unescape()` 函数已经被废弃，并不推荐在新的代码中使用。推荐使用更安全的 `decodeURI()` 或 `decodeURIComponent()` 函数来进行字符串解码。这些函数提供了更好的性能和可靠性，并且符合最新的标准规范。
>
> 例如，使用 `decodeURI()` 可以实现相同的解码效果：
>
> ```js
> const decodedString = decodeURI(encodedString);
> console.log(decodedString);
> ```
>
> 总结起来，`unescape()` 是 JavaScript 中的一个全局函数，用于将编码后的字符串解码为原始字符串。然而，它已经被废弃，推荐使用 `decodeURI()` 或 `decodeURIComponent()` 函数进行字符串解码。
>
> ​	
>
> 参考链接🔗
>
> [sessionStorage 、localStorage 和 cookie 之间的区别](https://juejin.cn/post/6844903713098694664)
>
> [cookie、localStorage和sessionStorage 三者之间的区别以及存储、获取、删除等使用方式](https://juejin.cn/post/6844903516826255373)

- [x] 10 get请求和post请求的区别是啥

- [x] 11 你的学习路径怎么样？怎么学习前端技术的？

- [x] 12 看过vue3的源码吗？

现在是vue2然后原生技术开发吗？

> 现在主要是vue2+js进行开发，后面会慢慢更新自己的技术栈，往vue3+ts的方向走

- [x] 13 你的包管理工具用的什么？

> npm

- [x] yarn有用过吗？（了解一下）[中文文档](https://yarn.bootcss.com/)

> 没有

- [x] npm的优缺点？

> npm（Node Package Manager）是 Node.js 的包管理器，用于安装、发布和管理 JavaScript 包。它是 JavaScript 生态系统中最常用的包管理工具之一。下面是 npm 的一些优点和缺点：
>
> 优点：
>
> 1. 大量的包资源：npm 是一个庞大的包存储库，拥有数以万计的开源包供开发者使用，可以满足各种开发需求。
> 2. 简单易用：npm 的命令行界面简单易懂，使得安装、更新和卸载包变得非常方便。同时，它提供了丰富的文档和社区支持，方便开发者查找和解决问题。
> 3. 包版本管理：npm 具有灵活的版本管理功能，可以选择性地安装和使用特定版本的包。这对于项目的依赖管理非常重要，可以确保项目在不同环境中的一致性。
> 4. 生态系统支持：npm 是 JavaScript 生态系统的核心，与其他工具和框架紧密配合。许多流行的前端工具（如Webpack、Babel）都使用 npm 来管理依赖关系。
>
> 缺点：
>
> 1. **包质量不一**：由于 npm 上的包数量庞大，包的质量和可靠性也有差异。有时候需要仔细选择和评估包的质量，以避免使用不稳定或有安全问题的包。
> 2. **依赖管理复杂**：在大型项目中，依赖项的管理可能变得复杂。**npm 依赖的嵌套结构**可能导致依赖冲突或版本不一致的问题。这需要开发者小心处理依赖关系，确保项目的稳定性。
> 3. **模块冲突**：当不同的包依赖于相同的模块但使用不同的版本时，可能会导致模块冲突。解决这种冲突可能需要进行手动配置或使用其他工具。
> 4. **包发布和版本管理**：由于 npm 上的包数量庞大，包的命名空间有限，可能会导致包名冲突。同时，包的版本发布和管理需要开发者遵循一定的规范和最佳实践。
>
> 综上所述，npm 是一个强大的包管理工具，为 JavaScript 开发者提供了丰富的资源和便利性。然而，在使用时需要小心处理依赖关系、选择可靠的包，并遵循最佳实践以确保项目的稳定性和可维护性。
>
> ## npm和yarn的区别
>
> npm（Node Package Manager）和 Yarn 都是 JavaScript 的包管理工具，用于安装、发布和管理 JavaScript 包。它们在某些方面有一些区别：
>
> 1. **性能和速度：** Yarn 在包的安装过程中使用了**并行和缓存机制**，因此通常比 npm 更快速。Yarn 的锁定文件（`yarn.lock`）确保每个依赖项的版本都是确定的，这有助于避免依赖冲突，并提供可复现的构建过程。
> 2. **安装过程：** Yarn 的安装过程更加可靠和稳定。它使用一个**单独的进程**来处理所有包的下载和安装，而 npm 则在安装过程中可能会执行一些预安装和后安装的脚本，这可能会导致一些不可预测的行为。
> 3. **版本解析算法：** npm 5 之前的版本解析算法在解决依赖冲突时可能会有一些问题，而 Yarn 使用了更先进的版本解析算法，能够更好地处理依赖关系，并找到满足所有依赖的最优解。
> 4. **用户界面和交互性：** Yarn 提供了一个更友好和交互式的命令行界面，可以显示更多有用的信息，如进度条和更详细的错误信息。npm 在最新版本中也对用户界面进行了改进，提供了类似的功能。
> 5. **社区支持和生态系统：** npm 是 JavaScript 生态系统的核心，并且拥有庞大的包存储库。因此，npm 上的包数量更多，可以满足更广泛的需求。同时，npm 也有一个强大的社区支持和活跃的贡献者。
>
> 综上所述，Yarn 相对于 npm 具有更快的安装速度、更可靠的安装过程和更好的版本解析算法。但是，npm 作为 JavaScript 生态系统的核心，具有更大的包数量和更广泛的社区支持。选择使用 npm 还是 Yarn 取决于项目需求、团队偏好和个人喜好。

- [x] 14 dns解析的过程

> DNS（Domain Name System）解析是将域名（例如，[www.example.com）转换为对应的](http://www.example.xn--com)-yh5f514eofecrlum7bub2c/) IP 地址的过程。下面是 DNS 解析的简要过程：
>
> 1. **发起请求：** 当用户在浏览器中输入一个域名时，浏览器会向本地 DNS 解析器（通常由网络服务提供商提供）发送 DNS 解析请求。
> 2. **本地缓存查找：** 解析器首先会检查本地缓存中是否有对应域名的 IP 地址记录。如果找到了缓存记录并且还没有过期，解析器会直接返回缓存的 IP 地址，跳过后续步骤。
> 3. **递归查询：** 如果本地缓存中没有找到对应的 IP 地址记录，解析器将会向根域名服务器发送一个递归查询请求，询问域名的顶级域名服务器（TLD，例如 .com、.org）的 IP 地址。
> 4. **TLD 服务器响应：** 根域名服务器会返回顶级域名服务器的 IP 地址给解析器。
> 5. **顶级域名服务器查询：** 解析器接着向顶级域名服务器发送查询请求，询问负责目标域名的权威域名服务器的 IP 地址。
> 6. **权威域名服务器响应：** 权威域名服务器会返回目标域名的 IP 地址给解析器。
> 7. **解析结果返回：** 解析器收到目标域名的 IP 地址后，将其存储到本地缓存中以备将来使用，并将解析结果返回给浏览器。
> 8. **浏览器发起请求：** 浏览器接收到解析器返回的 IP 地址后，将使用该 IP 地址向目标服务器发送请求。
> 9. **建立连接：** 浏览器与目标服务器之间建立 TCP/IP 连接，并开始发送和接收数据。
>
> 总结起来，DNS 解析的过程涉及多个步骤，包括本地缓存查找、递归查询、顶级域名服务器查询和权威域名服务器响应。这些步骤协同工作，将域名解析为对应的 IP 地址，使得浏览器能够与目标服务器建立连接并访问网站。
>
> ## 讲一下三次握手
>
> 三次握手是在 TCP（Transmission Control Protocol）协议中用于建立可靠的连接的过程。下面是三次握手的简要过程：
>
> 1. **第一次握手 - SYN（同步）：** 客户端发送一个带有 SYN 标志的 TCP 报文段给服务器，表示客户端请求建立连接。这时客户端进入 SYN_SENT（同步已发送）状态。
> 2. **第二次握手 - SYN + ACK（确认）：** 服务器收到客户端的 SYN 请求后，如果同意建立连接，会发送一个带有 SYN 和 ACK 标志的 TCP 报文段作为响应。ACK 确认号表示服务器接收到了客户端的 SYN 请求，并将其加一作为自己的初始序列号。此时服务器进入 SYN_RCVD（同步已接收）状态。
> 3. **第三次握手 - ACK：** 客户端收到服务器的 SYN+ACK 响应后，会发送一个带有 ACK 标志的 TCP 报文段给服务器。这个报文段的序列号会加一作为下一个数据包的初始序列号。服务器收到客户端的 ACK 后，进入 ESTABLISHED（已建立连接）状态，而客户端也进入 ESTABLISHED 状态，此时连接建立成功。
>
> 通过三次握手，客户端和服务器都确认了对方的接收能力和发送能力，并且双方都同意建立连接。这种机制可以确保数据能够可靠地传输，同时防止旧的连接请求被误认为是新的连接。
>
> 需要注意的是，三次握手只是建立连接的过程，并不涉及数据传输。在连接建立之后，客户端和服务器可以开始传输数据，并通过四次挥手来关闭连接。三次握手是 TCP 协议中保证连接可靠性的重要步骤之一。
>
> ## 讲一下四次挥手
>
> 在 TCP 协议中，关闭连接是通过四次挥手（Four-way handshake）完成的。下面是四次挥手的过程：
>
> 1. **第一次挥手 - FIN（结束）：** 当一方（客户端或服务器）希望关闭连接时，发送一个带有 FIN 标志的 TCP 报文段给对方，表示自己没有数据要发送了。发送方进入 FIN_WAIT_1（等待对方的确认关闭）状态。
> 2. **第二次挥手 - ACK：** 接收方收到 FIN 请求后，发送一个带有 ACK 标志的 TCP 报文段作为响应。这个报文段的 ACK 确认号表示对前一个报文段的确认，同时表示自己还有数据要发送。接收方进入 CLOSE_WAIT（等待发送方关闭）状态，而发送方进入 FIN_WAIT_2（等待对方的确认关闭）状态。
> 3. **第三次挥手 - FIN：** 当接收方希望关闭连接时，发送一个带有 FIN 标志的 TCP 报文段给发送方，表示自己也没有数据要发送了。接收方进入 LAST_ACK（等待最后的确认关闭）状态。
> 4. **第四次挥手 - ACK：** 发送方收到 FIN 请求后，发送一个带有 ACK 标志的 TCP 报文段作为响应。接收方收到 ACK 后，进入 CLOSED（已关闭）状态，而发送方等待一段时间后也进入 CLOSED 状态。
>
> 通过四次挥手，双方完成了对连接的关闭，确保数据的完整性和可靠性。需要注意的是，四次挥手过程中的 ACK 报文段可能携带数据，因为在关闭连接之前，双方可能还有剩余的数据要传输。四次挥手确保了双方都完成了数据的传输和确认，从而安全地关闭连接。
>
> ## SYN 标志是什么
>
> SYN（Synchronize）标志是 TCP 报文段中的一个控制位，用于建立 TCP 连接时的握手过程。SYN 标志在 TCP 头部的 Flags 字段中表示为 1。下面是 SYN 标志的作用和含义：
>
> 1. **建立连接：** SYN 标志用于建立连接时的第一次握手。当一方（通常是客户端）发送带有 SYN 标志的 TCP 报文段给另一方（通常是服务器），表示发起连接请求。
> 2. **序列号的同步：** SYN 报文段中的序列号字段用于同步连接的初始序列号。发送方的序列号表示该报文段的初始序列号，而接收方的序列号表示下一个期望接收的数据序列号。
> 3. **确认 SYN：** 接收方收到带有 SYN 标志的 TCP 报文段后，会发送一个带有 SYN 和 ACK（确认）标志的响应报文段作为确认。这个响应报文段的序列号表示接收方期望接收的下一个数据序列号。
>
> 通过 SYN 标志，双方在建立连接时可以协商初始序列号，并确保双方对序列号的理解是一致的。SYN 标志是 TCP 握手过程中的重要标志之一，用于建立连接的可靠性和安全性。
>
> ## ACK 报文段是什么
>
> ACK（Acknowledgment）报文段是 TCP 报文段中的一个控制位，用于确认接收数据和确认序列号的值。ACK 标志在 TCP 头部的 Flags 字段中表示为 1。下面是 ACK 报文段的作用和含义：
>
> 1. **确认接收数据：** ACK 报文段用于确认接收方成功收到前一个序列号的数据。当接收方收到数据后，会发送一个带有 ACK 标志的 TCP 报文段作为确认。ACK 报文段中的确认号表示接收方期望接收的下一个数据序列号。
> 2. **确认序列号的值：** ACK 报文段中的确认号字段表示发送方期望接收的下一个数据序列号。发送方根据接收到的 ACK 报文段中的确认号更新自己的序列号，并确保双方对序列号的理解是一致的。
> 3. **组合控制位：** ACK 标志与其他控制位（如 SYN、FIN）可以组合使用，以便在 TCP 报文段中同时传递多个控制信息。例如，一个带有 SYN+ACK 标志的报文段表示接收方确认连接请求，并向发送方发起连接的确认。
>
> 通过 ACK 报文段，发送方和接收方可以进行数据传输的确认和序列号的协商。ACK 标志是 TCP 协议中用于确认和确认序列号的重要标志，确保数据传输的可靠性和顺序性。
>
> ## SYN、FIN、ACK都是什么名词的缩写
>
> SYN、FIN和ACK是TCP（Transmission Control Protocol）协议中的控制位，它们
>
> 代表了不同的功能和含义。下面是它们的缩写和对应的含义：
>
> 1. **SYN**：SYN是"Synchronize"的缩写，表示同步。在TCP连接的建立过程中，SYN用于发起连接请求，并同步双方的初始序列号。
> 2. **FIN**：FIN是"Finish"的缩写，表示结束。当一方希望关闭TCP连接时，会发送一个带有FIN标志的报文段，表示自己没有数据要发送了，请求关闭连接。
> 3. **ACK**：ACK是"Acknowledgment"的缩写，表示确认。ACK用于确认接收方成功收到数据或者确认序列号的值。在TCP报文段中，ACK标志表示报文段中的确认号字段是有效的。
>
> 这些控制位在TCP协议中起着重要的作用，用于建立连接、关闭连接以及确认数据的传输。它们的使用可以确保可靠的数据传输和连接的可靠性。



你在广州为什么会想来杭州这边实习呢？有朋友过来吗？

> 父母在那边发展，所以实习也在那边

​	

你对加班这个事情是怎么看待的？

> 前期实习加班可以理解嘛，跟上公司业务
>
> 自己的工作在规定时间内那加班很正常嘛，可以理解，但一直加班就不正常咯

​	

我的提问：

公司上班时间怎么样的？

> 早上8点半到下午6点，可弹性一个小时，最晚早上9点半上班，晚上7点下班，（一天工作8小时）中午休息1个多时间

加班有加班费吗？

> 没有，但有餐补

公司配电脑吗？可以用自己的电脑吗？

> 配，mac笔记本，原则上不允许自己的电脑