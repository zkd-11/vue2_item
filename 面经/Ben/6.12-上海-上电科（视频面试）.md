# 6.12-上海-上电科

## 项目是自己做的吗？

- 对，第一个是团队项目，第二个是个人开发的

## 极客是pc端的吗？移动端也能看吗？

手机没做适配（面试官是觉得有点像移动端的目录，也有pages目录）

## 微信/支付宝接口

​	

**问些技术问题**

## 说一下基本数据类型有哪些

​	

## null和undefined有什么区别？

== 相等吗？true

=== 相等吗？false（null是object，undefined不是object）

​	

## 引用对象赋值（浅拷贝）

- 解释了浅拷贝和深拷贝

## 想做深拷贝怎么做？有哪些方式

- 回答：自定义函数，创建临时变量去做
- 面试官提示：api，parse
- JSON.parse和[JSON.stringify()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)连用

## JSON.parse和[JSON.stringify()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)具体怎么用，哪个先哪个后

先用stringify变为json再用parse解析json为对象

GPT：

实现深拷贝是为了创建一个完全独立的对象副本，使其与原始对象没有任何引用关系。这样，在修改副本时不会影响原始对象。下面介绍几种常用的方式来实现深拷贝：

1. 使用JSON序列化和反序列化：可以通过将对象转换为JSON字符串，然后再将JSON字符串转换回对象来实现深拷贝。这种方法简单易用，但有一些限制，例如无法复制函数和特殊的对象类型。

```js
const deepCopy = (obj) => {
  return JSON.parse(JSON.stringify(obj));
};
```

1. 递归遍历复制：可以编写一个递归函数，遍历对象的每个属性，并逐个复制到新的对象中。递归地处理对象的嵌套属性，以实现深层复制。

```js
const deepCopy = (obj) => {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  let copy = Array.isArray(obj) ? [] : {};

  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      copy[key] = deepCopy(obj[key]);
    }
  }

  return copy;
};
```

1. 使用第三方库：还可以使用一些第三方库来实现深拷贝，例如lodash的`cloneDeep`方法。

```js
const _ = require('lodash');

const deepCopy = (obj) => {
  return _.cloneDeep(obj);
};
```

这些方式都可以实现深拷贝，但在选择时需要考虑对象的复杂性、性能和需求的具体情况。JSON序列化和反序列化简单易用，但有一些限制。递归遍历复制更灵活，但可能在处理循环引用时导致死循环。第三方库提供了成熟和高效的解决方案，但需要额外的依赖。根据具体情况选择合适的方式来实现深拷贝。

​	

## 讲一下es6新特性

​	

## async和await有用过吗？

​	

## 你请求后端接口用的什么？

- axios和ajax用比较多

​	

## let和const有什么区别

​	

## const定义的变量可以改变吗？

### 如果我想改变某一个对象的属性值，可以吗？

回答的：基本数据类型是不能修改，引用类型数据不确定

GPT：

在使用`const`声明引用类型的对象时，变量本身是不可重新赋值的，但是对象的属性值是可以修改的。这是因为`const`声明的是一个常量引用，它指向的对象在内存中是固定的，不能再指向其他对象，但是对象本身的属性是可以修改的。

下面是一个示例：

```js
const obj = { name: "John", age: 25 };

obj.name = "Alice";  // 可以修改对象的属性值
obj.age = 30;

console.log(obj);  // 输出: { name: "Alice", age: 30 }
```

在上面的代码中，虽然使用`const`声明了`obj`变量，但是我们仍然可以通过`obj`来修改其属性值。这是因为`const`只保证变量引用的对象是不变的，而不保证对象本身的属性值不变。

然而，如果尝试重新赋值给`obj`变量，就会产生一个错误：

```js
const obj = { name: "John", age: 25 };

obj = { name: "Alice", age: 30 };  // TypeError: Assignment to constant variable.
```

在上面的代码中，尝试将一个新的对象赋值给`obj`变量时，会抛出`TypeError`错误，因为`const`声明的变量不能重新赋值。

因此，使用`const`声明引用类型的对象时，虽然不能重新赋值给变量，但是可以修改对象的属性值。

​	

## 对于数据的循环遍历知道几种方式

for

forEach

map

for in

fifter

​	

### fifter会影响原数组吗，是返回一个新数组吗？

​	

### some方法用过吗？

并讲了下every

​	

## 讲一下vue生命周期钩子函数有哪些

回答的：8个，用中文回答，面试官问我知道英文名吗😢

在Vue.js中，组件的生命周期钩子函数用于在组件不同的生命周期阶段执行特定的操作。以下是Vue的生命周期钩子函数及其触发时机：

1. `beforeCreate`：在实例初始化之后、数据观测（data observation）和事件/生命周期事件配置之前调用。此时组件实例尚未创建，无法访问到组件的数据和方法。
2. `created`：在实例创建完成后被调用。此时组件实例已经创建完成，可以访问到组件的数据和方法。可以在这个钩子函数中进行数据的初始化、异步操作的请求等。
3. `beforeMount`：在组件挂载到DOM之前被调用。此时模板已经编译完成，但尚未挂载到DOM上。
4. `mounted`：在组件挂载到DOM之后被调用。此时组件已经被渲染到页面上，并且可以访问到挂载后的DOM元素。可以在这个钩子函数中进行DOM操作、添加事件监听器等。
5. `beforeUpdate`：在数据更新之前被调用。在这个钩子函数中，可以访问到更新前的数据和DOM状态。
6. `updated`：在数据更新之后被调用。在这个钩子函数中，可以访问到更新后的数据和DOM状态。注意：避免在此钩子函数中进行数据修改，以免导致无限循环的更新。
7. `beforeUnmount`（Vue 3.0+，替代了`beforeDestroy`）：在组件卸载之前被调用。在这个钩子函数中，可以进行一些清理工作，例如**取消订阅、清除计时器**等。
8. `unmounted`（Vue 3.0+，替代了`destroyed`）：在组件卸载之后被调用。在这个钩子函数中，**组件实例已经被销毁**，可以进行一些清理工作。
9. `errorCaptured`（Vue 2.5.0+）：在子孙组件抛出错误时被调用，用于捕获错误并进行处理。

这些生命周期钩子函数提供了在组件不同阶段执行代码的机会，可以根据需要在相应的钩子函数中进行初始化、数据请求、DOM操作、清理工作等。

​	

## created和amounted有什么区别

创建后和挂载后？

​	

### created里能拿到dom吗

回答的：挂载后才可以，amounted

​	

## 销毁函数用过吗？

### 什么时候要用到销毁函数？

回答的：变量/组件用完销毁

GPT：

销毁函数通常在以下情况下使用：

1. Vue组件销毁：在使用Vue.js开发应用程序时，组件会经历创建、更新和销毁等生命周期阶段。当一个组件被销毁时，可以使用销毁函数来执行一些清理工作，例如取消订阅、清除计时器、释放资源等。销毁函数可以在组件的`beforeUnmount`（Vue 3.0+）或`destroyed`（Vue 2.0）生命周期钩子函数中定义。
2. 监听器和订阅的取消：当在应用程序中使用监听器或订阅来监听事件或数据的变化时，需要在不再需要监听时及时取消监听。这可以通过销毁函数来实现。例如，在使用`addEventListener`方法添加事件监听器后，可以使用`removeEventListener`方法来取消监听，以避免内存泄漏。同样，使用订阅模式（如观察者模式或发布-订阅模式）时，也应该在不需要订阅的时候取消订阅。
3. 清理资源和释放内存：在应用程序中使用一些资源，例如打开的文件、网络连接、数据库连接等，当不再需要这些资源时，需要及时进行清理和释放。销毁函数可以用来关闭连接、释放资源，以避免资源泄漏和浪费。

使用销毁函数可以确保在不再需要某些资源或操作时，进行及时的清理和释放。这有助于提高应用程序的性能和资源利用率，并避免潜在的问题，如内存泄漏和资源耗尽。因此，当存在这样的场景时，使用销毁函数是一个良好的实践。

​	

## computed和watch有什么区别？

​	

### watch有两个常用属性知道吗？

面试官提示：比如刚进页面watch监听不到，然后这个属性可以，一进到这个页面就触发，因为进到页面watch的对象可能没变化，但是我希望一进页面就watch监听？

- 不了解，不会

面试官：那如果监听一个对象，我想要深度监听，监听这个对象的属性名，某个属性，这种深度监听用哪个属性？

---

在Vue.js中，`watch`属性用于监听Vue实例中的数据变化，并在数据发生变化时执行相应的操作。`watch`属性有两个常用的属性：

1. `handler`：`handler`是一个函数，用于定义数据变化时所要执行的操作。当被监视的数据发生变化时，`handler`函数将被触发执行。

```js
watch: {
  // 监听data中的message属性
  message: function(newVal, oldVal) {
    // 数据变化时执行的操作
    console.log('数据发生变化：', newVal, oldVal);
  }
}
```

1. `deep`：`deep`是一个布尔值，用于指定是否深度监听被监视的数据的变化。默认情况下，Vue只会浅层监听数据变化，即当被监视的数据的引用发生变化时才会触发`watch`。如果将`deep`设置为`true`，Vue将会递归监听被监视数据的所有嵌套属性的变化。

```js
watch: {
  // 深度监听data中的obj对象
  obj: {
    handler: function(newVal, oldVal) {
      // 数据变化时执行的操作
      console.log('数据发生变化：', newVal, oldVal);
    },
    deep: true
  }
}
```

通过使用`watch`属性，你可以监视Vue实例中的数据变化，并根据需要执行相应的操作。这对于处理复杂的数据依赖和响应式行为非常有用。

​	

## 知道常用的几个vue指令吗？

Vue.js中有许多常用的指令，用于在模板中实现动态绑定和操作。以下是一些常用的Vue指令：

1. `v-bind`：用于动态绑定数据到元素的属性上，可以简写为`:`。例如：`<img v-bind:src="imageUrl">`。
2. `v-if`：根据表达式的值来条件性地渲染元素，如果条件为`true`，则元素会被渲染；如果条件为`false`，则元素不会被渲染。
3. `v-show`：根据表达式的值来切换元素的显示和隐藏，如果条件为`true`，则元素显示；如果条件为`false`，则元素隐藏。
4. `v-for`：用于遍历数组或对象，并渲染多个元素。可以使用特殊变量（如`item`、`index`等）来访问遍历过程中的数据。例如：`<li v-for="item in items">{{ item }}</li>`。
5. `v-on`：用于监听DOM事件，并执行相应的方法，可以简写为`@`。例如：`<button v-on:click="handleClick">Click me</button>`。
6. `v-model`：用于实现双向数据绑定，将表单元素的值与Vue实例中的数据进行关联。例如：`<input v-model="message">`。
7. `v-text`：将元素的文本内容与Vue实例中的数据进行绑定，相当于使用`{{ }}`插值表达式。例如：`<span v-text="message"></span>`。
8. `v-html`：将元素的`innerHTML`内容与Vue实例中的数据进行绑定，可以渲染包含HTML标签的文本。请注意潜在的安全风险。

这只是一小部分常用的Vue指令，Vue还有其他指令可以实现更多的功能和交互效果。你可以根据项目需求和具体情况选择适合的指令来操作和控制Vue应用程序的行为。

​	

### 讲一下v-if和v-show的区别

​	

### 知道v-for有一个key值吗？对它赋值的话有什么要求？

#### 你知道key值都是唯一的，你知道为什么吗？

- 窜讲了keep-alive的作用，讲的不好

#### 你key一般赋什么值

- index

​	

## 说下vue通信方式有哪些

bus、props/emit

面试官：还有吗？

我：不会了

### 说一下props/emit怎么用的

​	

## vuex用过吗？有用过它什么方法

​	

### vuex定义state的值是永久保存的吗？

- 我：应该不是

#### 我点下刷新，值还在吗？

我说在，面试官说不会保存

然后我说存储用web storage

​	

## 持久化存储用哪种方式

我：localstorage

面试官：sessionstorage呢？

说了他们的区别

​	

## 一个数组，每个元素都是一个对象，对象有属性，你改变了其中某一个值但在页面上没有生效，遇到过吗？

面试官提示：跟双向绑定有关系，vue2文档里有说

我：好像遇到过，跟生命周期有关系吗？

面试官：没关系，你听说过$set吗

set数据结构知道，vue里的$set没听过

​	

## 说几个css居中的方式吧

说了3个

​	

## 知道文字居中吗？

text-align=center？

​	

## less或scss有用过啊？

我：用过scss和stylus，比原生css多了嵌套使用和函数式

​	

## 知道scope吗，在style标签里的

- 局部的，只对当前组件生效

​	

## git用过吗？

### 说下项目提交到远程仓库用到什么命令

​	

## 组件库用的element-ui吗？

​	

公司主要技术栈是

vue2、elementui、uniapp

​	

没有vue3/react

​	

日常实习内容是跟着面试官写pc端的代码

​	

## 对我的面试评价怎么样？

还可以，有些问题没答上来也理解，没遇到过

​	

## 测试代码有规范吗公司？

没有，自己觉得OK就合并

